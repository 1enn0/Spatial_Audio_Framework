<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Spatial_Audio_Framework: /Users/mccorml1/Documents/SourceTree/SPARTA_VSTs_public/SDKs/Spatial_Audio_Framework/framework/modules/saf_utilities/saf_veclib.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Spatial_Audio_Framework
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('saf__veclib_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">saf_veclib.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Contains wrappers for optimised linear algebra routines, utilising CBLAS and LAPACK.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;math.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &quot;<a class="el" href="saf__complex_8h_source.html">saf_complex.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="saf__error_8h_source.html">saf_error.h</a>&quot;</code><br />
</div>
<p><a href="saf__veclib_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aae947cf66c5c406780552ea4160c81ba"><td class="memItemLeft" align="right" valign="top"><a id="aae947cf66c5c406780552ea4160c81ba"></a>
typedef enum <a class="el" href="saf__veclib_8h.html#ae14a034f95fe809e0570621a76343ef4">_TRANS_FLAG</a>&#160;</td><td class="memItemRight" valign="bottom"><b>TRANS_FLAG</b></td></tr>
<tr class="separator:aae947cf66c5c406780552ea4160c81ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00433bae942d708adb926d8b3c741549"><td class="memItemLeft" align="right" valign="top"><a id="a00433bae942d708adb926d8b3c741549"></a>
typedef enum <a class="el" href="saf__veclib_8h.html#aa55d6660dd98e88fd4a1ae1282e1b49d">_CONJ_FLAG</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CONJ_FLAG</b></td></tr>
<tr class="separator:a00433bae942d708adb926d8b3c741549"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ae14a034f95fe809e0570621a76343ef4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__veclib_8h.html#ae14a034f95fe809e0570621a76343ef4">_TRANS_FLAG</a> { <a class="el" href="saf__veclib_8h.html#ae14a034f95fe809e0570621a76343ef4a528f2fb55315b680200ab0fcb49e6b48">NO_TRANSPOSE</a> = 1, 
<a class="el" href="saf__veclib_8h.html#ae14a034f95fe809e0570621a76343ef4a3416ba33b450af93f7e5944a20253e68">TRANSPOSE</a> = 2, 
<a class="el" href="saf__veclib_8h.html#ae14a034f95fe809e0570621a76343ef4ac3369d58ac4c64e5dded167e945a7261">CONJ_TRANSPOSE</a> = 3
 }</td></tr>
<tr class="separator:ae14a034f95fe809e0570621a76343ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa55d6660dd98e88fd4a1ae1282e1b49d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__veclib_8h.html#aa55d6660dd98e88fd4a1ae1282e1b49d">_CONJ_FLAG</a> { <a class="el" href="saf__veclib_8h.html#aa55d6660dd98e88fd4a1ae1282e1b49da067cd409aeb9fbf93ccd17291119fe38">NO_CONJ</a> = 1, 
<a class="el" href="saf__veclib_8h.html#aa55d6660dd98e88fd4a1ae1282e1b49da26a53d2d0576982e73a770a90087a619">CONJ</a> = 2
 }</td></tr>
<tr class="separator:aa55d6660dd98e88fd4a1ae1282e1b49d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af34cdd4172744886a0ed8d5c938ed93b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__veclib_8h.html#af34cdd4172744886a0ed8d5c938ed93b">utility_siminv</a> (const float *a, const int len, int *index)</td></tr>
<tr class="memdesc:af34cdd4172744886a0ed8d5c938ed93b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single-precision, index of minimum absolute value in a vector, i.e.  <a href="saf__veclib_8h.html#af34cdd4172744886a0ed8d5c938ed93b">More...</a><br /></td></tr>
<tr class="separator:af34cdd4172744886a0ed8d5c938ed93b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47f536159d4f1c1ecd05a8f13f10a2d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__veclib_8h.html#a47f536159d4f1c1ecd05a8f13f10a2d5">utility_ciminv</a> (const float_complex *a, const int len, int *index)</td></tr>
<tr class="memdesc:a47f536159d4f1c1ecd05a8f13f10a2d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single-precision, complex, index of maximum absolute value in a vector, i.e.  <a href="saf__veclib_8h.html#a47f536159d4f1c1ecd05a8f13f10a2d5">More...</a><br /></td></tr>
<tr class="separator:a47f536159d4f1c1ecd05a8f13f10a2d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af733d65eaed0015c6ba428a07eda867a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__veclib_8h.html#af733d65eaed0015c6ba428a07eda867a">utility_simaxv</a> (const float *a, const int len, int *index)</td></tr>
<tr class="memdesc:af733d65eaed0015c6ba428a07eda867a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single-precision, index of maximum absolute value in a vector, i.e.  <a href="saf__veclib_8h.html#af733d65eaed0015c6ba428a07eda867a">More...</a><br /></td></tr>
<tr class="separator:af733d65eaed0015c6ba428a07eda867a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6600bec30da8cb52c95697fc81ded614"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__veclib_8h.html#a6600bec30da8cb52c95697fc81ded614">utility_cimaxv</a> (const float_complex *a, const int len, int *index)</td></tr>
<tr class="memdesc:a6600bec30da8cb52c95697fc81ded614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single-precision, complex, index of maximum absolute value in a vector, i.e.  <a href="saf__veclib_8h.html#a6600bec30da8cb52c95697fc81ded614">More...</a><br /></td></tr>
<tr class="separator:a6600bec30da8cb52c95697fc81ded614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaaae918746a4c589ea33cc62ea079fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__veclib_8h.html#aeaaae918746a4c589ea33cc62ea079fb">utility_svabs</a> (const float *a, const int len, float *c)</td></tr>
<tr class="memdesc:aeaaae918746a4c589ea33cc62ea079fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single-precision, absolute values of vector elements, i.e.  <a href="saf__veclib_8h.html#aeaaae918746a4c589ea33cc62ea079fb">More...</a><br /></td></tr>
<tr class="separator:aeaaae918746a4c589ea33cc62ea079fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a911b4a7ea87c93e71e870c27b5ae32ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__veclib_8h.html#a911b4a7ea87c93e71e870c27b5ae32ba">utility_cvabs</a> (const float_complex *a, const int len, float *c)</td></tr>
<tr class="memdesc:a911b4a7ea87c93e71e870c27b5ae32ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single-precision, complex, absolute values of vector elements, i.e.  <a href="saf__veclib_8h.html#a911b4a7ea87c93e71e870c27b5ae32ba">More...</a><br /></td></tr>
<tr class="separator:a911b4a7ea87c93e71e870c27b5ae32ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64608bbabb1b7bfd135fbb982a4d1e2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__veclib_8h.html#a64608bbabb1b7bfd135fbb982a4d1e2c">utility_svvcopy</a> (const float *a, const int len, float *c)</td></tr>
<tr class="memdesc:a64608bbabb1b7bfd135fbb982a4d1e2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single-precision, vector-vector copy, i.e.  <a href="saf__veclib_8h.html#a64608bbabb1b7bfd135fbb982a4d1e2c">More...</a><br /></td></tr>
<tr class="separator:a64608bbabb1b7bfd135fbb982a4d1e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac335cac027bcb24d435f9a525587d9d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__veclib_8h.html#ac335cac027bcb24d435f9a525587d9d4">utility_cvvcopy</a> (const float_complex *a, const int len, float_complex *c)</td></tr>
<tr class="memdesc:ac335cac027bcb24d435f9a525587d9d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single-precision, complex, vector-vector copy, i.e.  <a href="saf__veclib_8h.html#ac335cac027bcb24d435f9a525587d9d4">More...</a><br /></td></tr>
<tr class="separator:ac335cac027bcb24d435f9a525587d9d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab30537b80e8e4e3706598a0409e93434"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__veclib_8h.html#ab30537b80e8e4e3706598a0409e93434">utility_svvadd</a> (float *a, const float *b, const int len, float *c)</td></tr>
<tr class="memdesc:ab30537b80e8e4e3706598a0409e93434"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single-precision, vector-vector addition, i.e.  <a href="saf__veclib_8h.html#ab30537b80e8e4e3706598a0409e93434">More...</a><br /></td></tr>
<tr class="separator:ab30537b80e8e4e3706598a0409e93434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74d6a552aab364739efe6a0474d9d33f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__veclib_8h.html#a74d6a552aab364739efe6a0474d9d33f">utility_cvvadd</a> (float_complex *a, const float_complex *b, const int len, float_complex *c)</td></tr>
<tr class="memdesc:a74d6a552aab364739efe6a0474d9d33f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single-precision, complex, vector-vector addition, i.e.  <a href="saf__veclib_8h.html#a74d6a552aab364739efe6a0474d9d33f">More...</a><br /></td></tr>
<tr class="separator:a74d6a552aab364739efe6a0474d9d33f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addfcc5edcfe16fec544393a762d35e1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__veclib_8h.html#addfcc5edcfe16fec544393a762d35e1c">utility_svvsub</a> (float *a, const float *b, const int len, float *c)</td></tr>
<tr class="memdesc:addfcc5edcfe16fec544393a762d35e1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single-precision, vector-vector subtraction, i.e.  <a href="saf__veclib_8h.html#addfcc5edcfe16fec544393a762d35e1c">More...</a><br /></td></tr>
<tr class="separator:addfcc5edcfe16fec544393a762d35e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4ea3747055fde12ec79e81c4eb02755"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__veclib_8h.html#ab4ea3747055fde12ec79e81c4eb02755">utility_cvvsub</a> (float_complex *a, const float_complex *b, const int len, float_complex *c)</td></tr>
<tr class="memdesc:ab4ea3747055fde12ec79e81c4eb02755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single-precision, complex, vector-vector subtraction, i.e.  <a href="saf__veclib_8h.html#ab4ea3747055fde12ec79e81c4eb02755">More...</a><br /></td></tr>
<tr class="separator:ab4ea3747055fde12ec79e81c4eb02755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affb907cad281bbfae4258f615431d8e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__veclib_8h.html#affb907cad281bbfae4258f615431d8e1">utility_svvmul</a> (float *a, const float *b, const int len, float *c)</td></tr>
<tr class="memdesc:affb907cad281bbfae4258f615431d8e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single-precision, element-wise vector-vector multiplication i.e.  <a href="saf__veclib_8h.html#affb907cad281bbfae4258f615431d8e1">More...</a><br /></td></tr>
<tr class="separator:affb907cad281bbfae4258f615431d8e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cedb44e24c42582413629cd17c16ed1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__veclib_8h.html#a5cedb44e24c42582413629cd17c16ed1">utility_cvvmul</a> (float_complex *a, const float_complex *b, const int len, float_complex *c)</td></tr>
<tr class="memdesc:a5cedb44e24c42582413629cd17c16ed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single-precision, complex, element-wise vector-vector multiplication i.e.  <a href="saf__veclib_8h.html#a5cedb44e24c42582413629cd17c16ed1">More...</a><br /></td></tr>
<tr class="separator:a5cedb44e24c42582413629cd17c16ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae190ef14372ec0af61a4ac2da3b2c77d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__veclib_8h.html#ae190ef14372ec0af61a4ac2da3b2c77d">utility_svvdot</a> (const float *a, const float *b, const int len, float *c)</td></tr>
<tr class="memdesc:ae190ef14372ec0af61a4ac2da3b2c77d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single-precision, vector-vector dot product, i.e.  <a href="saf__veclib_8h.html#ae190ef14372ec0af61a4ac2da3b2c77d">More...</a><br /></td></tr>
<tr class="separator:ae190ef14372ec0af61a4ac2da3b2c77d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9172e1212262a626b93912ff375ad3d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__veclib_8h.html#a9172e1212262a626b93912ff375ad3d8">utility_cvvdot</a> (const float_complex *a, const float_complex *b, const int len, CONJ_FLAG flag, float_complex *c)</td></tr>
<tr class="memdesc:a9172e1212262a626b93912ff375ad3d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single-precision, complex, vector-vector dot product, i.e.  <a href="saf__veclib_8h.html#a9172e1212262a626b93912ff375ad3d8">More...</a><br /></td></tr>
<tr class="separator:a9172e1212262a626b93912ff375ad3d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed09df6b262daceb834b98dd9eeb202c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__veclib_8h.html#aed09df6b262daceb834b98dd9eeb202c">utility_svsmul</a> (float *a, const float *s, const int len, float *c)</td></tr>
<tr class="memdesc:aed09df6b262daceb834b98dd9eeb202c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single-precision, multiplies each element in vector 'a' with a scalar 's', i.e.  <a href="saf__veclib_8h.html#aed09df6b262daceb834b98dd9eeb202c">More...</a><br /></td></tr>
<tr class="separator:aed09df6b262daceb834b98dd9eeb202c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4044ddbce451c1d2d1d8afb51201c1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__veclib_8h.html#ad4044ddbce451c1d2d1d8afb51201c1d">utility_cvsmul</a> (float_complex *a, const float_complex *s, const int len, float_complex *c)</td></tr>
<tr class="memdesc:ad4044ddbce451c1d2d1d8afb51201c1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single-precision, complex, multiplies each element in vector 'a' with a scalar 's', i.e.  <a href="saf__veclib_8h.html#ad4044ddbce451c1d2d1d8afb51201c1d">More...</a><br /></td></tr>
<tr class="separator:ad4044ddbce451c1d2d1d8afb51201c1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a276ba1a0ca7334ae617d359cd6068b4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__veclib_8h.html#a276ba1a0ca7334ae617d359cd6068b4c">utility_svsdiv</a> (float *a, const float *s, const int len, float *c)</td></tr>
<tr class="memdesc:a276ba1a0ca7334ae617d359cd6068b4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single-precision, divides each element in vector 'a' with a scalar 's', i.e.  <a href="saf__veclib_8h.html#a276ba1a0ca7334ae617d359cd6068b4c">More...</a><br /></td></tr>
<tr class="separator:a276ba1a0ca7334ae617d359cd6068b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46848011ca30d85e0a4a6a3015b3cf30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__veclib_8h.html#a46848011ca30d85e0a4a6a3015b3cf30">utility_svsadd</a> (float *a, const float *s, const int len, float *c)</td></tr>
<tr class="memdesc:a46848011ca30d85e0a4a6a3015b3cf30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single-precision, adds each element in vector 'a' with a scalar 's', i.e.  <a href="saf__veclib_8h.html#a46848011ca30d85e0a4a6a3015b3cf30">More...</a><br /></td></tr>
<tr class="separator:a46848011ca30d85e0a4a6a3015b3cf30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48aca79eea1ca15a66e1e9a42e75f872"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__veclib_8h.html#a48aca79eea1ca15a66e1e9a42e75f872">utility_svssub</a> (float *a, const float *s, const int len, float *c)</td></tr>
<tr class="memdesc:a48aca79eea1ca15a66e1e9a42e75f872"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single-precision, subtracts each element in vector 'a' with a scalar 's', i.e.  <a href="saf__veclib_8h.html#a48aca79eea1ca15a66e1e9a42e75f872">More...</a><br /></td></tr>
<tr class="separator:a48aca79eea1ca15a66e1e9a42e75f872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c3d3d052a568162922532db6cddfc4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__veclib_8h.html#ac0c3d3d052a568162922532db6cddfc4">utility_ssvd</a> (const float *A, const int dim1, const int dim2, float *U, float *S, float *V, float *sing)</td></tr>
<tr class="memdesc:ac0c3d3d052a568162922532db6cddfc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Row-major, singular value decomposition: single precision, i.e.  <a href="saf__veclib_8h.html#ac0c3d3d052a568162922532db6cddfc4">More...</a><br /></td></tr>
<tr class="separator:ac0c3d3d052a568162922532db6cddfc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6179a4dacf4a921e7fe17947cf5d526"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__veclib_8h.html#af6179a4dacf4a921e7fe17947cf5d526">utility_csvd</a> (const float_complex *A, const int dim1, const int dim2, float_complex *U, float_complex *S, float_complex *V, float *sing)</td></tr>
<tr class="memdesc:af6179a4dacf4a921e7fe17947cf5d526"><td class="mdescLeft">&#160;</td><td class="mdescRight">Row-major, singular value decomposition: single precision complex, i.e.  <a href="saf__veclib_8h.html#af6179a4dacf4a921e7fe17947cf5d526">More...</a><br /></td></tr>
<tr class="separator:af6179a4dacf4a921e7fe17947cf5d526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65951b425b0083086afcfb5410965bcf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__veclib_8h.html#a65951b425b0083086afcfb5410965bcf">utility_sseig</a> (const float *A, const int dim, int sortDecFLAG, float *V, float *D, float *eig)</td></tr>
<tr class="memdesc:a65951b425b0083086afcfb5410965bcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Row-major, eigenvalue decomposition of a SYMMETRIC matrix: single precision, i.e.  <a href="saf__veclib_8h.html#a65951b425b0083086afcfb5410965bcf">More...</a><br /></td></tr>
<tr class="separator:a65951b425b0083086afcfb5410965bcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad464ffe7795e3e9200bd8f70ae10aaed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__veclib_8h.html#ad464ffe7795e3e9200bd8f70ae10aaed">utility_cseig</a> (const float_complex *A, const int dim, int sortDecFLAG, float_complex *V, float_complex *D, float *eig)</td></tr>
<tr class="memdesc:ad464ffe7795e3e9200bd8f70ae10aaed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Row-major, eigenvalue decomposition of a SYMMETRIC/HERMITION matrix: single precision complex, i.e.  <a href="saf__veclib_8h.html#ad464ffe7795e3e9200bd8f70ae10aaed">More...</a><br /></td></tr>
<tr class="separator:ad464ffe7795e3e9200bd8f70ae10aaed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0eb807aa2c6063482ad285f5e93d078"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__veclib_8h.html#ac0eb807aa2c6063482ad285f5e93d078">utility_ceigmp</a> (const float_complex *A, const float_complex *B, const int dim, float_complex *VL, float_complex *VR, float_complex *D)</td></tr>
<tr class="memdesc:ac0eb807aa2c6063482ad285f5e93d078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Row-major, finds eigenvalues of a matrix pair using the QZ method, single precision complex, i.e.  <a href="saf__veclib_8h.html#ac0eb807aa2c6063482ad285f5e93d078">More...</a><br /></td></tr>
<tr class="separator:ac0eb807aa2c6063482ad285f5e93d078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67f31570fc67b10ba4e95a0ff6527c31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__veclib_8h.html#a67f31570fc67b10ba4e95a0ff6527c31">utility_zeigmp</a> (const double_complex *A, const double_complex *B, const int dim, double_complex *VL, double_complex *VR, double_complex *D)</td></tr>
<tr class="memdesc:a67f31570fc67b10ba4e95a0ff6527c31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Row-major, finds eigenvalues of a matrix pair using the QZ method, double precision complex, i.e.  <a href="saf__veclib_8h.html#a67f31570fc67b10ba4e95a0ff6527c31">More...</a><br /></td></tr>
<tr class="separator:a67f31570fc67b10ba4e95a0ff6527c31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a666f092fb86f59006f20fd8bd7fdd4c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__veclib_8h.html#a666f092fb86f59006f20fd8bd7fdd4c0">utility_ceig</a> (const float_complex *A, const int dim, int sortDecFLAG, float_complex *VL, float_complex *VR, float_complex *D, float *eig)</td></tr>
<tr class="memdesc:a666f092fb86f59006f20fd8bd7fdd4c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Row-major, eigenvalue decomposition of a NON-SYMMETRIC matrix: single precision complex, i.e.  <a href="saf__veclib_8h.html#a666f092fb86f59006f20fd8bd7fdd4c0">More...</a><br /></td></tr>
<tr class="separator:a666f092fb86f59006f20fd8bd7fdd4c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeec5ce24423452a5910fad61592ed2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__veclib_8h.html#aeeec5ce24423452a5910fad61592ed2e">utility_sglslv</a> (const float *A, const int dim, float *B, int nCol, float *X)</td></tr>
<tr class="memdesc:aeeec5ce24423452a5910fad61592ed2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Row-major, general linear solver: single precision, i.e.  <a href="saf__veclib_8h.html#aeeec5ce24423452a5910fad61592ed2e">More...</a><br /></td></tr>
<tr class="separator:aeeec5ce24423452a5910fad61592ed2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b4f131d17c9a2706cdffc244aa23966"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__veclib_8h.html#a1b4f131d17c9a2706cdffc244aa23966">utility_cglslv</a> (const float_complex *A, const int dim, float_complex *B, int nCol, float_complex *X)</td></tr>
<tr class="memdesc:a1b4f131d17c9a2706cdffc244aa23966"><td class="mdescLeft">&#160;</td><td class="mdescRight">Row-major, general linear solver: single precision complex, i.e.  <a href="saf__veclib_8h.html#a1b4f131d17c9a2706cdffc244aa23966">More...</a><br /></td></tr>
<tr class="separator:a1b4f131d17c9a2706cdffc244aa23966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17069fa770f13431c9cfab601e523dba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__veclib_8h.html#a17069fa770f13431c9cfab601e523dba">utility_dglslv</a> (const double *A, const int dim, double *B, int nCol, double *X)</td></tr>
<tr class="memdesc:a17069fa770f13431c9cfab601e523dba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Row-major, general linear solver: double precision, i.e.  <a href="saf__veclib_8h.html#a17069fa770f13431c9cfab601e523dba">More...</a><br /></td></tr>
<tr class="separator:a17069fa770f13431c9cfab601e523dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a632cb1a3d3d300793b57548e1396dc1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__veclib_8h.html#a632cb1a3d3d300793b57548e1396dc1b">utility_zglslv</a> (const double_complex *A, const int dim, double_complex *B, int nCol, double_complex *X)</td></tr>
<tr class="memdesc:a632cb1a3d3d300793b57548e1396dc1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Row-major, general linear solver: double precision complex, i.e.  <a href="saf__veclib_8h.html#a632cb1a3d3d300793b57548e1396dc1b">More...</a><br /></td></tr>
<tr class="separator:a632cb1a3d3d300793b57548e1396dc1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79e970ff977245de479e5d35985571e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__veclib_8h.html#a79e970ff977245de479e5d35985571e9">utility_sslslv</a> (const float *A, const int dim, float *B, int nCol, float *X)</td></tr>
<tr class="memdesc:a79e970ff977245de479e5d35985571e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Row-major, linear solver for SYMMETRIC positive-definate 'A': single precision, i.e.  <a href="saf__veclib_8h.html#a79e970ff977245de479e5d35985571e9">More...</a><br /></td></tr>
<tr class="separator:a79e970ff977245de479e5d35985571e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e1d1425139473e12d239460be5fd89a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__veclib_8h.html#a6e1d1425139473e12d239460be5fd89a">utility_cslslv</a> (const float_complex *A, const int dim, float_complex *B, int nCol, float_complex *X)</td></tr>
<tr class="memdesc:a6e1d1425139473e12d239460be5fd89a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Row-major, linear solver for HERMITIAN positive-definate 'A': single precision complex, i.e.  <a href="saf__veclib_8h.html#a6e1d1425139473e12d239460be5fd89a">More...</a><br /></td></tr>
<tr class="separator:a6e1d1425139473e12d239460be5fd89a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af293a508cab1f40438c6a7d4ed9fe7f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__veclib_8h.html#af293a508cab1f40438c6a7d4ed9fe7f7">utility_spinv</a> (const float *A, const int dim1, const int dim2, float *B)</td></tr>
<tr class="memdesc:af293a508cab1f40438c6a7d4ed9fe7f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Row-major, general matrix pseudo-inverse (the svd way): single precision, i.e.  <a href="saf__veclib_8h.html#af293a508cab1f40438c6a7d4ed9fe7f7">More...</a><br /></td></tr>
<tr class="separator:af293a508cab1f40438c6a7d4ed9fe7f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a095d19777532245389f3f56ece4f525f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__veclib_8h.html#a095d19777532245389f3f56ece4f525f">utility_cpinv</a> (const float_complex *A, const int dim1, const int dim2, float_complex *B)</td></tr>
<tr class="memdesc:a095d19777532245389f3f56ece4f525f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Row-major, general matrix pseudo-inverse (the svd way): single precision complex, i.e.  <a href="saf__veclib_8h.html#a095d19777532245389f3f56ece4f525f">More...</a><br /></td></tr>
<tr class="separator:a095d19777532245389f3f56ece4f525f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9ffb2224a784bef03cd2f31cd11bec3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__veclib_8h.html#aa9ffb2224a784bef03cd2f31cd11bec3">utility_dpinv</a> (const double *A, const int dim1, const int dim2, double *B)</td></tr>
<tr class="memdesc:aa9ffb2224a784bef03cd2f31cd11bec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Row-major, general matrix pseudo-inverse (the svd way): double precision, i.e.  <a href="saf__veclib_8h.html#aa9ffb2224a784bef03cd2f31cd11bec3">More...</a><br /></td></tr>
<tr class="separator:aa9ffb2224a784bef03cd2f31cd11bec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23af6a0378cb1f925532d432f637d34d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__veclib_8h.html#a23af6a0378cb1f925532d432f637d34d">utility_zpinv</a> (const double_complex *A, const int dim1, const int dim2, double_complex *B)</td></tr>
<tr class="memdesc:a23af6a0378cb1f925532d432f637d34d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Row-major, general matrix pseudo-inverse (the svd way): double precision complex, i.e.  <a href="saf__veclib_8h.html#a23af6a0378cb1f925532d432f637d34d">More...</a><br /></td></tr>
<tr class="separator:a23af6a0378cb1f925532d432f637d34d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54b9362bf8fcc59ae910b5b5614ae96f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__veclib_8h.html#a54b9362bf8fcc59ae910b5b5614ae96f">utility_schol</a> (const float *A, const int dim, float *X)</td></tr>
<tr class="memdesc:a54b9362bf8fcc59ae910b5b5614ae96f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Row-major, Cholesky factorisation of a symmetric matrix positive-definate matrix: single precision, i.e.  <a href="saf__veclib_8h.html#a54b9362bf8fcc59ae910b5b5614ae96f">More...</a><br /></td></tr>
<tr class="separator:a54b9362bf8fcc59ae910b5b5614ae96f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20cae9b6d71f1299053d0f09a5846b93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__veclib_8h.html#a20cae9b6d71f1299053d0f09a5846b93">utility_cchol</a> (const float_complex *A, const int dim, float_complex *X)</td></tr>
<tr class="memdesc:a20cae9b6d71f1299053d0f09a5846b93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Row-major, Cholesky factorisation of a hermitian matrix positive-definate matrix: single precision complex, i.e.  <a href="saf__veclib_8h.html#a20cae9b6d71f1299053d0f09a5846b93">More...</a><br /></td></tr>
<tr class="separator:a20cae9b6d71f1299053d0f09a5846b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa39b67da4ca044646a1ba4012149459a"><td class="memItemLeft" align="right" valign="top"><a id="aa39b67da4ca044646a1ba4012149459a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>utility_sinv</b> (float *A, const int N)</td></tr>
<tr class="separator:aa39b67da4ca044646a1ba4012149459a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a057bfce46541cdc602cc1e074a2e930c"><td class="memItemLeft" align="right" valign="top"><a id="a057bfce46541cdc602cc1e074a2e930c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>utility_dinv</b> (double *A, const int N)</td></tr>
<tr class="separator:a057bfce46541cdc602cc1e074a2e930c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae35e146d14b12d9e80db773cc4fa03c8"><td class="memItemLeft" align="right" valign="top"><a id="ae35e146d14b12d9e80db773cc4fa03c8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>utility_cinv</b> (float_complex *A, const int N)</td></tr>
<tr class="separator:ae35e146d14b12d9e80db773cc4fa03c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Contains wrappers for optimised linear algebra routines, utilising CBLAS and LAPACK. </p>
<h2><a class="anchor" id="autotoc_md27"></a>
Dependencies</h2>
<p>A performance library comprising CBLAS and LAPACK routines is required by the module and, thus, also by the SAF framework as a whole. Add one of the following FLAGS to your project's preprocessor definitions list, in order to enable one of these suitable performance libraries, which must also be linked correctly to your project.</p><ul>
<li>SAF_USE_INTEL_MKL: to enable Intel's Math Kernal Library</li>
<li>SAF_USE_ATLAS_WITH_LAPACK: to enable ATLAS BLAS routines with netlib's LAPACK see: <a href="http://math-atlas.sourceforge.net/atlas_install/node8.html">http://math-atlas.sourceforge.net/atlas_install/node8.html</a></li>
<li>SAF_USE_OPENBLAS_WITH_LAPACK: to enable OpenBLAS and use netlib's LAPACK</li>
</ul>
<dl class="section see"><dt>See also</dt><dd>More information can be found here: <a href="https://github.com/leomccormack/Spatial_Audio_Framework">https://github.com/leomccormack/Spatial_Audio_Framework</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>MacOSX users only: saf_utilities will employ Apple's Accelerate library by default, if none of the above FLAGS are defined.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Leo McCormack </dd></dl>
<dl class="section date"><dt>Date</dt><dd>11.07.2016 </dd></dl>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="aa55d6660dd98e88fd4a1ae1282e1b49d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa55d6660dd98e88fd4a1ae1282e1b49d">&#9670;&nbsp;</a></span>_CONJ_FLAG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="saf__veclib_8h.html#aa55d6660dd98e88fd4a1ae1282e1b49d">_CONJ_FLAG</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa55d6660dd98e88fd4a1ae1282e1b49da067cd409aeb9fbf93ccd17291119fe38"></a>NO_CONJ&#160;</td><td class="fielddoc"><p>Do not take the conjugate. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa55d6660dd98e88fd4a1ae1282e1b49da26a53d2d0576982e73a770a90087a619"></a>CONJ&#160;</td><td class="fielddoc"><p>Take the conjugate. </p>
</td></tr>
</table>

</div>
</div>
<a id="ae14a034f95fe809e0570621a76343ef4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae14a034f95fe809e0570621a76343ef4">&#9670;&nbsp;</a></span>_TRANS_FLAG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="saf__veclib_8h.html#ae14a034f95fe809e0570621a76343ef4">_TRANS_FLAG</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae14a034f95fe809e0570621a76343ef4a528f2fb55315b680200ab0fcb49e6b48"></a>NO_TRANSPOSE&#160;</td><td class="fielddoc"><p>Do not transpose. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae14a034f95fe809e0570621a76343ef4a3416ba33b450af93f7e5944a20253e68"></a>TRANSPOSE&#160;</td><td class="fielddoc"><p>Transpose. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae14a034f95fe809e0570621a76343ef4ac3369d58ac4c64e5dded167e945a7261"></a>CONJ_TRANSPOSE&#160;</td><td class="fielddoc"><p>Conjugate transpose / Hermition. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a20cae9b6d71f1299053d0f09a5846b93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20cae9b6d71f1299053d0f09a5846b93">&#9670;&nbsp;</a></span>utility_cchol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void utility_cchol </td>
          <td>(</td>
          <td class="paramtype">const float_complex *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Row-major, Cholesky factorisation of a hermitian matrix positive-definate matrix: single precision complex, i.e. </p>
<div class="fragment"><div class="line">X = chol(A); where A = X.<span class="stringliteral">&#39;*X</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>Input square symmetric positive-definate matrix; FLAT: dim x dim </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Number of rows/colums in 'A' </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td>The solution; FLAT: dim x dim </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a666f092fb86f59006f20fd8bd7fdd4c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a666f092fb86f59006f20fd8bd7fdd4c0">&#9670;&nbsp;</a></span>utility_ceig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void utility_ceig </td>
          <td>(</td>
          <td class="paramtype">const float_complex *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sortDecFLAG</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>VL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>VR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>eig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Row-major, eigenvalue decomposition of a NON-SYMMETRIC matrix: single precision complex, i.e. </p>
<div class="fragment"><div class="line">[VL,VR,D] = eig(A); where A*VR = VR*D, and  A*VR = VR*diag(eig)</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>'D' contains the eigen values along the diagonal, while 'eig' are the eigen values as a vector</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>Input NON-SYMMETRIC square matrix; FLAT: dim x dim </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Dimensions for square matrix 'A' </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sortDecFLAG</td><td>'1' sort eigen values and vectors in decending order. '0' ascending </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VL</td><td>Left Eigen vectors (set to NULL if not needed); FLAT: dim x dim </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VR</td><td>Right Eigen vectors (set to NULL if not needed); FLAT: dim x dim </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">D</td><td>Eigen values along the diagonal (set to NULL if not needed); FLAT: dim x dim </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">eig</td><td>Eigen values not diagonalised (set to NULL if not needed); dim x 1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac0eb807aa2c6063482ad285f5e93d078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0eb807aa2c6063482ad285f5e93d078">&#9670;&nbsp;</a></span>utility_ceigmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void utility_ceigmp </td>
          <td>(</td>
          <td class="paramtype">const float_complex *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float_complex *&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>VL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>VR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Row-major, finds eigenvalues of a matrix pair using the QZ method, single precision complex, i.e. </p>
<div class="fragment"><div class="line">[VL,VR,D] = eig(A,B,<span class="stringliteral">&#39;qz&#39;</span>); where A*VL = B*VL*VR</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>Input left square matrix; FLAT: dim x dim </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>Input right square matrix; FLAT: dim x dim </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Dimensions for square matrices 'A' and 'B' </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VL</td><td>Left Eigen vectors (set to NULL if not needed); FLAT: dim x dim </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VR</td><td>Right Eigen vectors (set to NULL if not needed); FLAT: dim x dim </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">D</td><td>Eigen values along the diagonal (set to NULL if not needed); FLAT: dim x dim </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b4f131d17c9a2706cdffc244aa23966"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b4f131d17c9a2706cdffc244aa23966">&#9670;&nbsp;</a></span>utility_cglslv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void utility_cglslv </td>
          <td>(</td>
          <td class="paramtype">const float_complex *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nCol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Row-major, general linear solver: single precision complex, i.e. </p>
<div class="fragment"><div class="line">X = linsolve(A,B) = A\B; where, AX = B</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>Input square matrix; FLAT: dim x dim </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Dimensions for square matrix 'A' </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>Right hand side matrix; FLAT: dim x nCol </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nCol</td><td>Number of columns in right hand side matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td>The solution; FLAT: dim x nCol </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6600bec30da8cb52c95697fc81ded614"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6600bec30da8cb52c95697fc81ded614">&#9670;&nbsp;</a></span>utility_cimaxv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void utility_cimaxv </td>
          <td>(</td>
          <td class="paramtype">const float_complex *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Single-precision, complex, index of maximum absolute value in a vector, i.e. </p>
<div class="fragment"><div class="line">[~,ind] = max(abs(a))</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Input vector a; len x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Vector length </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">index</td><td>(&amp;) index of maximum value; 1 x 1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a47f536159d4f1c1ecd05a8f13f10a2d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47f536159d4f1c1ecd05a8f13f10a2d5">&#9670;&nbsp;</a></span>utility_ciminv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void utility_ciminv </td>
          <td>(</td>
          <td class="paramtype">const float_complex *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Single-precision, complex, index of maximum absolute value in a vector, i.e. </p>
<div class="fragment"><div class="line">[~,ind] = min(abs(a))</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Input vector a; len x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Vector length </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">index</td><td>(&amp;) index of minimum value; 1 x 1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a095d19777532245389f3f56ece4f525f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a095d19777532245389f3f56ece4f525f">&#9670;&nbsp;</a></span>utility_cpinv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void utility_cpinv </td>
          <td>(</td>
          <td class="paramtype">const float_complex *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Row-major, general matrix pseudo-inverse (the svd way): single precision complex, i.e. </p>
<div class="fragment"><div class="line">B = pinv(A)</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>Input matrix; FLAT: dim1 x dim2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim1</td><td>Number of rows in 'A' / columns in 'B' </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim2</td><td>Number of columns in 'A' / rows in 'B' </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">B</td><td>The solution; FLAT: dim2 x dim1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad464ffe7795e3e9200bd8f70ae10aaed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad464ffe7795e3e9200bd8f70ae10aaed">&#9670;&nbsp;</a></span>utility_cseig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void utility_cseig </td>
          <td>(</td>
          <td class="paramtype">const float_complex *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sortDecFLAG</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>eig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Row-major, eigenvalue decomposition of a SYMMETRIC/HERMITION matrix: single precision complex, i.e. </p>
<div class="fragment"><div class="line">[V,D] = eig(A); where A*V = V*D, and  A*V = V*diag(eig)</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>'D' contains the eigen values along the diagonal, while 'eig' are the eigen values as a vector</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>Input SYMMETRIC square matrix; FLAT: dim x dim </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Dimensions for square matrix 'A' </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sortDecFLAG</td><td>'1' sort eigen values and vectors in decending order. '0' ascending </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>Eigen vectors (set to NULL if not needed); FLAT: dim x dim </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">D</td><td>Eigen values along the diagonal (set to NULL if not needed); FLAT: dim x dim </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">eig</td><td>Eigen values not diagonalised (set to NULL if not needed); dim x 1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e1d1425139473e12d239460be5fd89a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e1d1425139473e12d239460be5fd89a">&#9670;&nbsp;</a></span>utility_cslslv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void utility_cslslv </td>
          <td>(</td>
          <td class="paramtype">const float_complex *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nCol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Row-major, linear solver for HERMITIAN positive-definate 'A': single precision complex, i.e. </p>
<div class="fragment"><div class="line">opts.LT=<span class="keyword">true</span></div>
<div class="line">X = linsolve(A,B, opts); where, AX = B</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>Input square SYMMETRIC positive-definate matrix; FLAT: dim x dim </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Dimensions for square matrix 'A' </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>Right hand side matrix; FLAT: dim x nCol </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nCol</td><td>Number of columns in right hand side matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td>The solution; FLAT: dim x nCol </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af6179a4dacf4a921e7fe17947cf5d526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6179a4dacf4a921e7fe17947cf5d526">&#9670;&nbsp;</a></span>utility_csvd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void utility_csvd </td>
          <td>(</td>
          <td class="paramtype">const float_complex *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>sing</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Row-major, singular value decomposition: single precision complex, i.e. </p>
<div class="fragment"><div class="line">[U,S,V] = svd(A); such that A = U*S*V<span class="stringliteral">&#39; = U*diag(sing)*V&#39;</span></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>'S' contains the singular values along the diagonal, whereas 'sing' are the singular values as a vector. Also, V is returned untransposed! (like in Matlab)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>Input matrix; FLAT: dim1 x dim2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim1</td><td>First dimension of matrix 'A' </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim2</td><td>Second dimension of matrix 'A' </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">U</td><td>Left matrix (set to NULL if not needed); FLAT: dim1 x dim1 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">S</td><td>Singular values along the diagonal min(dim1, dim2), (set to NULL if not needed); FLAT: dim1 x dim2 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>Right matrix (UNTRANSPOSED!) (set to NULL if not needed); FLAT: dim2 x dim2 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sing</td><td>Singular values as a vector, (set to NULL if not needed); min(dim1, dim2) x 1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a911b4a7ea87c93e71e870c27b5ae32ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a911b4a7ea87c93e71e870c27b5ae32ba">&#9670;&nbsp;</a></span>utility_cvabs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void utility_cvabs </td>
          <td>(</td>
          <td class="paramtype">const float_complex *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Single-precision, complex, absolute values of vector elements, i.e. </p>
<div class="fragment"><div class="line">c = abs(a)</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Input vector a; len x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Vector length </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">c</td><td>Output vector c; len x 1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad4044ddbce451c1d2d1d8afb51201c1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4044ddbce451c1d2d1d8afb51201c1d">&#9670;&nbsp;</a></span>utility_cvsmul()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void utility_cvsmul </td>
          <td>(</td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float_complex *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Single-precision, complex, multiplies each element in vector 'a' with a scalar 's', i.e. </p>
<div class="fragment"><div class="line">c = a.*s, OR: a = a.*s (<span class="keywordflow">if</span> c==NULL)</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Input vector a, and output if c==NULL; len x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>(&amp;) input scalar s; 1 x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Vector length </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">c</td><td>Output vector c (set to NULL if you want 'a' as output); </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a74d6a552aab364739efe6a0474d9d33f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74d6a552aab364739efe6a0474d9d33f">&#9670;&nbsp;</a></span>utility_cvvadd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void utility_cvvadd </td>
          <td>(</td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float_complex *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Single-precision, complex, vector-vector addition, i.e. </p>
<div class="fragment"><div class="line">c = a+b, OR: a = a+b (if c==NULL)</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Input vector a, and output if c==NULL; len x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Input vector b; len x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Vector length </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">c</td><td>Output vector c (set to NULL if you want 'a' as output); len x 1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac335cac027bcb24d435f9a525587d9d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac335cac027bcb24d435f9a525587d9d4">&#9670;&nbsp;</a></span>utility_cvvcopy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void utility_cvvcopy </td>
          <td>(</td>
          <td class="paramtype">const float_complex *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Single-precision, complex, vector-vector copy, i.e. </p>
<div class="fragment"><div class="line">c = a</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Input vector a; len x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Vector length </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">c</td><td>Output vector c; len x 1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9172e1212262a626b93912ff375ad3d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9172e1212262a626b93912ff375ad3d8">&#9670;&nbsp;</a></span>utility_cvvdot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void utility_cvvdot </td>
          <td>(</td>
          <td class="paramtype">const float_complex *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float_complex *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CONJ_FLAG&#160;</td>
          <td class="paramname"><em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Single-precision, complex, vector-vector dot product, i.e. </p>
<div class="fragment"><div class="line">c = a*b^T, (where size(c) = [1  1])</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Input vector a; len x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Input vector b; len x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Vector length </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">c</td><td>(&amp;) output vector c; 1 x 1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5cedb44e24c42582413629cd17c16ed1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cedb44e24c42582413629cd17c16ed1">&#9670;&nbsp;</a></span>utility_cvvmul()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void utility_cvvmul </td>
          <td>(</td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float_complex *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Single-precision, complex, element-wise vector-vector multiplication i.e. </p>
<div class="fragment"><div class="line">c = a.*b, OR: a = a.*b (<span class="keywordflow">if</span> c==NULL)</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Input vector a, and output if c==NULL; len x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Input vector b; len x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Vector length </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">c</td><td>Output vector c (set to NULL if you want 'a' as output); len x 1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab4ea3747055fde12ec79e81c4eb02755"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4ea3747055fde12ec79e81c4eb02755">&#9670;&nbsp;</a></span>utility_cvvsub()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void utility_cvvsub </td>
          <td>(</td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float_complex *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Single-precision, complex, vector-vector subtraction, i.e. </p>
<div class="fragment"><div class="line">c = a-b, OR: a = a-b (if c==NULL)</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Input vector a, and output if c==NULL; len x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Input vector b; len x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Vector length </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">c</td><td>Output vector c (set to NULL if you want 'a' as output); len x 1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a17069fa770f13431c9cfab601e523dba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17069fa770f13431c9cfab601e523dba">&#9670;&nbsp;</a></span>utility_dglslv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void utility_dglslv </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nCol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Row-major, general linear solver: double precision, i.e. </p>
<div class="fragment"><div class="line">X = linsolve(A,B) = A\B; where, AX = B</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>Input square matrix; FLAT: dim x dim </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Dimensions for square matrix 'A' </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>Right hand side matrix; FLAT: dim x nCol </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nCol</td><td>Number of columns in right hand side matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td>The solution; FLAT: dim x nCol </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa9ffb2224a784bef03cd2f31cd11bec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9ffb2224a784bef03cd2f31cd11bec3">&#9670;&nbsp;</a></span>utility_dpinv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void utility_dpinv </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Row-major, general matrix pseudo-inverse (the svd way): double precision, i.e. </p>
<div class="fragment"><div class="line">B = pinv(A)</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>Input matrix; FLAT: dim1 x dim2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim1</td><td>Number of rows in 'A' / columns in 'B' </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim2</td><td>Number of columns in 'A' / rows in 'B' </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">B</td><td>The solution; FLAT: dim2 x dim1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a54b9362bf8fcc59ae910b5b5614ae96f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54b9362bf8fcc59ae910b5b5614ae96f">&#9670;&nbsp;</a></span>utility_schol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void utility_schol </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Row-major, Cholesky factorisation of a symmetric matrix positive-definate matrix: single precision, i.e. </p>
<div class="fragment"><div class="line">X = chol(A); where A = X.<span class="stringliteral">&#39;*X</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>Input square symmetric positive-definate matrix; FLAT: dim x dim </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Number of rows/colums in 'A' </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td>The solution; FLAT: dim x dim </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeeec5ce24423452a5910fad61592ed2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeec5ce24423452a5910fad61592ed2e">&#9670;&nbsp;</a></span>utility_sglslv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void utility_sglslv </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nCol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Row-major, general linear solver: single precision, i.e. </p>
<div class="fragment"><div class="line">X = linsolve(A,B) = A\B; where, AX = B</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>Input square matrix; FLAT: dim x dim </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Dimensions for square matrix 'A' </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>Right hand side matrix; FLAT: dim x nCol </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nCol</td><td>Number of columns in right hand side matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td>The solution; FLAT: dim x nCol </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af733d65eaed0015c6ba428a07eda867a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af733d65eaed0015c6ba428a07eda867a">&#9670;&nbsp;</a></span>utility_simaxv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void utility_simaxv </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Single-precision, index of maximum absolute value in a vector, i.e. </p>
<div class="fragment"><div class="line">[~,ind] = max(abs(a))</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Input vector a; len x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Vector length </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">index</td><td>(&amp;) index of maximum value; 1 x 1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af34cdd4172744886a0ed8d5c938ed93b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af34cdd4172744886a0ed8d5c938ed93b">&#9670;&nbsp;</a></span>utility_siminv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void utility_siminv </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Single-precision, index of minimum absolute value in a vector, i.e. </p>
<div class="fragment"><div class="line">[~,ind] = min(abs(a))</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Input vector a; len x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Vector length </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">index</td><td>(&amp;) Index of minimum value; 1 x 1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af293a508cab1f40438c6a7d4ed9fe7f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af293a508cab1f40438c6a7d4ed9fe7f7">&#9670;&nbsp;</a></span>utility_spinv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void utility_spinv </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Row-major, general matrix pseudo-inverse (the svd way): single precision, i.e. </p>
<div class="fragment"><div class="line">B = pinv(A)</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>Input matrix; FLAT: dim1 x dim2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim1</td><td>Number of rows in 'A' / columns in 'B' </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim2</td><td>Number of columns in 'A' / rows in 'B' </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">B</td><td>The solution; FLAT: dim2 x dim1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a65951b425b0083086afcfb5410965bcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65951b425b0083086afcfb5410965bcf">&#9670;&nbsp;</a></span>utility_sseig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void utility_sseig </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sortDecFLAG</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>eig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Row-major, eigenvalue decomposition of a SYMMETRIC matrix: single precision, i.e. </p>
<div class="fragment"><div class="line">[V,D] = eig(A); where A*V = V*D, and  A*V = V*diag(eig)</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>'D' contains the eigen values along the diagonal, while 'eig' are the eigen values as a vector</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>Input SYMMETRIC square matrix; FLAT: dim x dim </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Dimensions for square matrix 'A' </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sortDecFLAG</td><td>'1' sort eigen values and vectors in decending order. '0' ascending </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>Eigen vectors (set to NULL if not needed); FLAT: dim x dim </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">D</td><td>Eigen values along the diagonal (set to NULL if not needed); FLAT: dim x dim </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">eig</td><td>Eigen values not diagonalised (set to NULL if not needed); dim x 1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a79e970ff977245de479e5d35985571e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79e970ff977245de479e5d35985571e9">&#9670;&nbsp;</a></span>utility_sslslv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void utility_sslslv </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nCol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Row-major, linear solver for SYMMETRIC positive-definate 'A': single precision, i.e. </p>
<div class="fragment"><div class="line">opts.LT=<span class="keyword">true</span></div>
<div class="line">X = linsolve(A,B, opts); where, AX = B</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>Input square SYMMETRIC positive-definate matrix; FLAT: dim x dim </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Dimensions for square matrix 'A' </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>Right hand side matrix; FLAT: dim x nCol </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nCol</td><td>Number of columns in right hand side matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td>The solution; FLAT: dim x nCol </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac0c3d3d052a568162922532db6cddfc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0c3d3d052a568162922532db6cddfc4">&#9670;&nbsp;</a></span>utility_ssvd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void utility_ssvd </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>sing</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Row-major, singular value decomposition: single precision, i.e. </p>
<div class="fragment"><div class="line">[U,S,V] = svd(A); such that A = U*S*V.<span class="stringliteral">&#39; = U*diag(sing)*V.&#39;</span></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>'S' contains the singular values along the diagonal, whereas 'sing' are the singular values as a vector. Also, V is returned untransposed! (like in Matlab)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>Input matrix; FLAT: dim1 x dim2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim1</td><td>First dimension of matrix 'A' </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim2</td><td>Second dimension of matrix 'A' </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">U</td><td>Left matrix (set to NULL if not needed); FLAT: dim1 x dim1 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">S</td><td>Singular values along the diagonal min(dim1, dim2), (set to NULL if not needed); FLAT: dim1 x dim2 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>Right matrix (UNTRANSPOSED!) (set to NULL if not needed); FLAT: dim2 x dim2 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sing</td><td>Singular values as a vector, (set to NULL if not needed); min(dim1, dim2) x 1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeaaae918746a4c589ea33cc62ea079fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaaae918746a4c589ea33cc62ea079fb">&#9670;&nbsp;</a></span>utility_svabs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void utility_svabs </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Single-precision, absolute values of vector elements, i.e. </p>
<div class="fragment"><div class="line">c = abs(a)</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Input vector a; len x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Vector length </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">c</td><td>Output vector c; len x 1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a46848011ca30d85e0a4a6a3015b3cf30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46848011ca30d85e0a4a6a3015b3cf30">&#9670;&nbsp;</a></span>utility_svsadd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void utility_svsadd </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Single-precision, adds each element in vector 'a' with a scalar 's', i.e. </p>
<div class="fragment"><div class="line">c = a+s, OR: a = a+s (if c==NULL)</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Input vector a, and output if c==NULL; len x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>(&amp;) input scalar s; 1 x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Vector length </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">c</td><td>Output vector c (set to NULL if you want 'a' as output); len x 1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a276ba1a0ca7334ae617d359cd6068b4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a276ba1a0ca7334ae617d359cd6068b4c">&#9670;&nbsp;</a></span>utility_svsdiv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void utility_svsdiv </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Single-precision, divides each element in vector 'a' with a scalar 's', i.e. </p>
<div class="fragment"><div class="line">c = a./s, OR: a = a./s (<span class="keywordflow">if</span> c==NULL)</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Input vector a, and output if c==NULL; len x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>(&amp;) input scalar s; 1 x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Vector length </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">c</td><td>Output vector c (set to NULL if you want 'a' as output); len x 1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed09df6b262daceb834b98dd9eeb202c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed09df6b262daceb834b98dd9eeb202c">&#9670;&nbsp;</a></span>utility_svsmul()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void utility_svsmul </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Single-precision, multiplies each element in vector 'a' with a scalar 's', i.e. </p>
<div class="fragment"><div class="line">c = a.*s, OR: a = a.*s (<span class="keywordflow">if</span> c==NULL)</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Input vector a, and output if c==NULL; len x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>(&amp;) input scalar s; 1 x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Vector length </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">c</td><td>Output vector c (set to NULL if you want 'a' as output); len x 1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a48aca79eea1ca15a66e1e9a42e75f872"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48aca79eea1ca15a66e1e9a42e75f872">&#9670;&nbsp;</a></span>utility_svssub()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void utility_svssub </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Single-precision, subtracts each element in vector 'a' with a scalar 's', i.e. </p>
<div class="fragment"><div class="line">c = a-s, OR: a = a-s (if c==NULL)</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Input vector a, and output if c==NULL; len x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>(&amp;) input scalar s; 1 x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Vector length </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">c</td><td>Output vector c (set to NULL if you want 'a' as output); len x 1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab30537b80e8e4e3706598a0409e93434"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab30537b80e8e4e3706598a0409e93434">&#9670;&nbsp;</a></span>utility_svvadd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void utility_svvadd </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Single-precision, vector-vector addition, i.e. </p>
<div class="fragment"><div class="line">c = a+b, OR: a = a+b (if c==NULL)</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Input vector a, and output if c==NULL; len x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Input vector b; len x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Vector length </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">c</td><td>Output vector c (set to NULL if you want 'a' as output); len x 1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64608bbabb1b7bfd135fbb982a4d1e2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64608bbabb1b7bfd135fbb982a4d1e2c">&#9670;&nbsp;</a></span>utility_svvcopy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void utility_svvcopy </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Single-precision, vector-vector copy, i.e. </p>
<div class="fragment"><div class="line">c = a</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Input vector a; len x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Vector length </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">c</td><td>Output vector c; len x 1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae190ef14372ec0af61a4ac2da3b2c77d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae190ef14372ec0af61a4ac2da3b2c77d">&#9670;&nbsp;</a></span>utility_svvdot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void utility_svvdot </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Single-precision, vector-vector dot product, i.e. </p>
<div class="fragment"><div class="line">c = a*b^T, (where size(c) = [1  1])</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Input vector a; len x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Input vector b; len x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Vector length </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">c</td><td>(&amp;) output vector c; 1 x 1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="affb907cad281bbfae4258f615431d8e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affb907cad281bbfae4258f615431d8e1">&#9670;&nbsp;</a></span>utility_svvmul()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void utility_svvmul </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Single-precision, element-wise vector-vector multiplication i.e. </p>
<div class="fragment"><div class="line">c = a.*b, OR: a = a.*b (<span class="keywordflow">if</span> c==NULL)</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Input vector a, and output if c==NULL; len x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Input vector b; len x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Vector length </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">c</td><td>Output vector c (set to NULL if you want 'a' as output); len x 1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="addfcc5edcfe16fec544393a762d35e1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addfcc5edcfe16fec544393a762d35e1c">&#9670;&nbsp;</a></span>utility_svvsub()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void utility_svvsub </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Single-precision, vector-vector subtraction, i.e. </p>
<div class="fragment"><div class="line">c = a-b, OR: a = a-b (if c==NULL)</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Input vector a, and output if c==NULL; len x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Input vector b; len x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Vector length </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">c</td><td>Output vector c (set to NULL if you want 'a' as output); len x 1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a67f31570fc67b10ba4e95a0ff6527c31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67f31570fc67b10ba4e95a0ff6527c31">&#9670;&nbsp;</a></span>utility_zeigmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void utility_zeigmp </td>
          <td>(</td>
          <td class="paramtype">const double_complex *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double_complex *&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double_complex *&#160;</td>
          <td class="paramname"><em>VL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double_complex *&#160;</td>
          <td class="paramname"><em>VR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double_complex *&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Row-major, finds eigenvalues of a matrix pair using the QZ method, double precision complex, i.e. </p>
<div class="fragment"><div class="line">[VL,VR,D] = eig(A,B,<span class="stringliteral">&#39;qz&#39;</span>); where A*VL = B*VL*VR</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>Input left square matrix; FLAT: dim x dim </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>Input right square matrix; FLAT: dim x dim </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Dimensions for square matrices 'A' and 'B' </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VL</td><td>Left Eigen vectors (set to NULL if not needed); FLAT: dim x dim </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VR</td><td>Right Eigen vectors (set to NULL if not needed); FLAT: dim x dim </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">D</td><td>Eigen values along the diagonal (set to NULL if not needed); FLAT: dim x dim </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a632cb1a3d3d300793b57548e1396dc1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a632cb1a3d3d300793b57548e1396dc1b">&#9670;&nbsp;</a></span>utility_zglslv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void utility_zglslv </td>
          <td>(</td>
          <td class="paramtype">const double_complex *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double_complex *&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nCol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double_complex *&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Row-major, general linear solver: double precision complex, i.e. </p>
<div class="fragment"><div class="line">X = linsolve(A,B) = A\B; where, AX = B</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>Input square matrix; FLAT: dim x dim </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Dimensions for square matrix 'A' </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>Right hand side matrix; FLAT: dim x nCol </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nCol</td><td>Number of columns in right hand side matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td>The solution; FLAT: dim x nCol </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a23af6a0378cb1f925532d432f637d34d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23af6a0378cb1f925532d432f637d34d">&#9670;&nbsp;</a></span>utility_zpinv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void utility_zpinv </td>
          <td>(</td>
          <td class="paramtype">const double_complex *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double_complex *&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Row-major, general matrix pseudo-inverse (the svd way): double precision complex, i.e. </p>
<div class="fragment"><div class="line">B = pinv(A)</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>Input matrix; FLAT: dim1 x dim2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim1</td><td>Number of rows in 'A' / columns in 'B' </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim2</td><td>Number of columns in 'A' / rows in 'B' </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">B</td><td>The solution; FLAT: dim2 x dim1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_644e041c3a6521da7b27eba0e4eb2b95.html">framework</a></li><li class="navelem"><a class="el" href="dir_56553b6b74e7f4a7717200a52c59b140.html">modules</a></li><li class="navelem"><a class="el" href="dir_ba0a5884162be49ca564693d469c3119.html">saf_utilities</a></li><li class="navelem"><a class="el" href="saf__veclib_8h.html">saf_veclib.h</a></li>
    <li class="footer">Generated on Wed Mar 4 2020 13:32:58 for Spatial_Audio_Framework by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Spatial_Audio_Framework: /Users/mccorml1/Documents/SourceTree/SPARTA_VSTs_public/SDKs/Spatial_Audio_Framework/framework/modules/saf_sh/saf_sh.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Spatial_Audio_Framework
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('saf__sh_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">saf_sh.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Public part of the "saf_sh" module.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="saf__complex_8h_source.html">../saf_utilities/saf_complex.h</a>&quot;</code><br />
</div>
<p><a href="saf__sh_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a2bac5e4831e0699171545c1d38558d7e"><td class="memItemLeft" align="right" valign="top"><a id="a2bac5e4831e0699171545c1d38558d7e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ORDER2NSH</b>(order)&#160;&#160;&#160;((order+1)*(order+1))</td></tr>
<tr class="separator:a2bac5e4831e0699171545c1d38558d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a89fc3daef304221a6826fd6916396e5f"><td class="memItemLeft" align="right" valign="top"><a id="a89fc3daef304221a6826fd6916396e5f"></a>
typedef enum <a class="el" href="saf__sh_8h.html#a6f72ce94d4f31c672211e7b98390d45a">_ARRAY_CONSTRUCTION_TYPES</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__sh_8h.html#a89fc3daef304221a6826fd6916396e5f">ARRAY_CONSTRUCTION_TYPES</a></td></tr>
<tr class="memdesc:a89fc3daef304221a6826fd6916396e5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Microphone/Hydrophone array contruction types. <br /></td></tr>
<tr class="separator:a89fc3daef304221a6826fd6916396e5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48746a72d4da48b8b442f5cdf76a378b"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="saf__sh_8h.html#a3e5dc1652d5020b211a8d9cf570e6052">_SECTOR_PATTERNS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__sh_8h.html#a48746a72d4da48b8b442f5cdf76a378b">SECTOR_PATTERNS</a></td></tr>
<tr class="memdesc:a48746a72d4da48b8b442f5cdf76a378b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sector pattern designs for directionally-contraining sound-fields [1].  <a href="saf__sh_8h.html#a48746a72d4da48b8b442f5cdf76a378b">More...</a><br /></td></tr>
<tr class="separator:a48746a72d4da48b8b442f5cdf76a378b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a6f72ce94d4f31c672211e7b98390d45a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__sh_8h.html#a6f72ce94d4f31c672211e7b98390d45a">_ARRAY_CONSTRUCTION_TYPES</a> { <a class="el" href="saf__sh_8h.html#a6f72ce94d4f31c672211e7b98390d45aaef2926e644b5529e6673d9af8cc5b0a1">ARRAY_CONSTRUCTION_OPEN</a>, 
<a class="el" href="saf__sh_8h.html#a6f72ce94d4f31c672211e7b98390d45aadd3f9c2386004df3244de2912dcdf496">ARRAY_CONSTRUCTION_OPEN_DIRECTIONAL</a>, 
<a class="el" href="saf__sh_8h.html#a6f72ce94d4f31c672211e7b98390d45aa5b24de1a578a08282bebacdf03cefa7d">ARRAY_CONSTRUCTION_RIGID</a>, 
<a class="el" href="saf__sh_8h.html#a6f72ce94d4f31c672211e7b98390d45aa046ccc1a8e502c8c952bb745def379b0">ARRAY_CONSTRUCTION_RIGID_DIRECTIONAL</a>
 }</td></tr>
<tr class="memdesc:a6f72ce94d4f31c672211e7b98390d45a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Microphone/Hydrophone array contruction types.  <a href="saf__sh_8h.html#a6f72ce94d4f31c672211e7b98390d45a">More...</a><br /></td></tr>
<tr class="separator:a6f72ce94d4f31c672211e7b98390d45a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e5dc1652d5020b211a8d9cf570e6052"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__sh_8h.html#a3e5dc1652d5020b211a8d9cf570e6052">_SECTOR_PATTERNS</a> { <a class="el" href="saf__sh_8h.html#a3e5dc1652d5020b211a8d9cf570e6052a0ee77a29b6b553c6965108d240f99ff7">SECTOR_PATTERN_PWD</a>, 
<a class="el" href="saf__sh_8h.html#a3e5dc1652d5020b211a8d9cf570e6052a9024988fa2c043c931936b0e4fae3055">SECTOR_PATTERN_MAXRE</a>, 
<a class="el" href="saf__sh_8h.html#a3e5dc1652d5020b211a8d9cf570e6052aa419a9e82484c4077a49ab1a4bdbe30f">SECTOR_PATTERN_CARDIOID</a>
 }</td></tr>
<tr class="memdesc:a3e5dc1652d5020b211a8d9cf570e6052"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sector pattern designs for directionally-contraining sound-fields [1].  <a href="saf__sh_8h.html#a3e5dc1652d5020b211a8d9cf570e6052">More...</a><br /></td></tr>
<tr class="separator:a3e5dc1652d5020b211a8d9cf570e6052"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac71d1d0c99dbe0cc27bd25790e04d779"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__sh_8h.html#ac71d1d0c99dbe0cc27bd25790e04d779">yawPitchRoll2Rzyx</a> (float yaw, float pitch, float roll, int rollPitchYawFLAG, float R[3][3])</td></tr>
<tr class="memdesc:ac71d1d0c99dbe0cc27bd25790e04d779"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a 3x3 rotation matrix from the Euler angles, using the yaw-pitch-roll (zyx) convention.  <a href="saf__sh_8h.html#ac71d1d0c99dbe0cc27bd25790e04d779">More...</a><br /></td></tr>
<tr class="separator:ac71d1d0c99dbe0cc27bd25790e04d779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a118e9de5ec5a4289f9bc935d89594202"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__sh_8h.html#a118e9de5ec5a4289f9bc935d89594202">unitSph2Cart</a> (float azi_rad, float elev_rad, float xyz[3])</td></tr>
<tr class="memdesc:a118e9de5ec5a4289f9bc935d89594202"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts spherical coordinates to cartesian coordinates of unit length.  <a href="saf__sh_8h.html#a118e9de5ec5a4289f9bc935d89594202">More...</a><br /></td></tr>
<tr class="separator:a118e9de5ec5a4289f9bc935d89594202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee36d05adf2e71f9e9559448622f0ca0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__sh_8h.html#aee36d05adf2e71f9e9559448622f0ca0">unitCart2Sph</a> (float xyz[3], float AziElev_rad[2])</td></tr>
<tr class="memdesc:aee36d05adf2e71f9e9559448622f0ca0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts cartesian coordinates of unit length to spherical coordinates.  <a href="saf__sh_8h.html#aee36d05adf2e71f9e9559448622f0ca0">More...</a><br /></td></tr>
<tr class="separator:aee36d05adf2e71f9e9559448622f0ca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dfd8725c78271229ee433e7d76899d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__sh_8h.html#a8dfd8725c78271229ee433e7d76899d0">unitCart2Sph_aziElev</a> (float xyz[3], float *azi_rad, float *elev_rad)</td></tr>
<tr class="memdesc:a8dfd8725c78271229ee433e7d76899d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts cartesian coordinates of unit length to spherical coordinates.  <a href="saf__sh_8h.html#a8dfd8725c78271229ee433e7d76899d0">More...</a><br /></td></tr>
<tr class="separator:a8dfd8725c78271229ee433e7d76899d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ff15ddf9e257b1f185421568ef349dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__sh_8h.html#a1ff15ddf9e257b1f185421568ef349dd">unnorm_legendreP</a> (int n, double *x, int lenX, double *y)</td></tr>
<tr class="memdesc:a1ff15ddf9e257b1f185421568ef349dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates unnormalised legendre polynomials up to order N, for all values in vector x [1].  <a href="saf__sh_8h.html#a1ff15ddf9e257b1f185421568ef349dd">More...</a><br /></td></tr>
<tr class="separator:a1ff15ddf9e257b1f185421568ef349dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3851842c7f6c520c3f645f0ae686443c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__sh_8h.html#a3851842c7f6c520c3f645f0ae686443c">unnorm_legendreP_recur</a> (int n, float *x, int lenX, float *Pnm_minus1, float *Pnm_minus2, float *Pnm)</td></tr>
<tr class="memdesc:a3851842c7f6c520c3f645f0ae686443c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates unnormalised legendre polynomials up to order N, for all values in vector x.  <a href="saf__sh_8h.html#a3851842c7f6c520c3f645f0ae686443c">More...</a><br /></td></tr>
<tr class="separator:a3851842c7f6c520c3f645f0ae686443c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adab8bc47f1068e8edd58e5d5c93a3fa4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__sh_8h.html#adab8bc47f1068e8edd58e5d5c93a3fa4">getSHreal</a> (int order, float *dirs_rad, int nDirs, float *Y)</td></tr>
<tr class="memdesc:adab8bc47f1068e8edd58e5d5c93a3fa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes REAL spherical harmonics [1] for each direction on the sphere.  <a href="saf__sh_8h.html#adab8bc47f1068e8edd58e5d5c93a3fa4">More...</a><br /></td></tr>
<tr class="separator:adab8bc47f1068e8edd58e5d5c93a3fa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf4d86ed458c9fcdb13065c7e2f4c436"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__sh_8h.html#abf4d86ed458c9fcdb13065c7e2f4c436">getSHreal_recur</a> (int order, float *dirs_rad, int nDirs, float *Y)</td></tr>
<tr class="memdesc:abf4d86ed458c9fcdb13065c7e2f4c436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes REAL spherical harmonics [1] for each direction on the sphere.  <a href="saf__sh_8h.html#abf4d86ed458c9fcdb13065c7e2f4c436">More...</a><br /></td></tr>
<tr class="separator:abf4d86ed458c9fcdb13065c7e2f4c436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f83c48c3d7c7f20726512e0495cf4b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__sh_8h.html#a4f83c48c3d7c7f20726512e0495cf4b9">getSHcomplex</a> (int order, float *dirs_rad, int nDirs, float_complex *Y)</td></tr>
<tr class="memdesc:a4f83c48c3d7c7f20726512e0495cf4b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes COMPLEX spherical harmonics [1] for each direction on the sphere.  <a href="saf__sh_8h.html#a4f83c48c3d7c7f20726512e0495cf4b9">More...</a><br /></td></tr>
<tr class="separator:a4f83c48c3d7c7f20726512e0495cf4b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bf53b93c2ccb874ee75088b769fb387"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__sh_8h.html#a8bf53b93c2ccb874ee75088b769fb387">complex2realSHMtx</a> (int order, float_complex *T_c2r)</td></tr>
<tr class="memdesc:a8bf53b93c2ccb874ee75088b769fb387"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a complex to real spherical harmonic transform matrix.  <a href="saf__sh_8h.html#a8bf53b93c2ccb874ee75088b769fb387">More...</a><br /></td></tr>
<tr class="separator:a8bf53b93c2ccb874ee75088b769fb387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1bf4d927842a9c97771801f2483b32d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__sh_8h.html#ae1bf4d927842a9c97771801f2483b32d">real2complexSHMtx</a> (int order, float_complex *T_r2c)</td></tr>
<tr class="memdesc:ae1bf4d927842a9c97771801f2483b32d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a real to complex spherical harmonic transform matrix.  <a href="saf__sh_8h.html#ae1bf4d927842a9c97771801f2483b32d">More...</a><br /></td></tr>
<tr class="separator:ae1bf4d927842a9c97771801f2483b32d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa25c6081b6abb92ca3545a879b9996e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__sh_8h.html#aa25c6081b6abb92ca3545a879b9996e4">complex2realCoeffs</a> (int order, float_complex *C_N, int K, float *R_N)</td></tr>
<tr class="memdesc:aa25c6081b6abb92ca3545a879b9996e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts SH coefficients from the complex to real basis.  <a href="saf__sh_8h.html#aa25c6081b6abb92ca3545a879b9996e4">More...</a><br /></td></tr>
<tr class="separator:aa25c6081b6abb92ca3545a879b9996e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb0681d04a190b7e1fe3d362f301f63e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__sh_8h.html#abb0681d04a190b7e1fe3d362f301f63e">getSHrotMtxReal</a> (float R[3][3], float *RotMtx, int L)</td></tr>
<tr class="memdesc:abb0681d04a190b7e1fe3d362f301f63e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a real-valued spherical harmonic rotation matrix [1] (assumes ACN channel ordering convention).  <a href="saf__sh_8h.html#abb0681d04a190b7e1fe3d362f301f63e">More...</a><br /></td></tr>
<tr class="separator:abb0681d04a190b7e1fe3d362f301f63e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb1a65a8f85a1505d0a96212775b4ae0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__sh_8h.html#acb1a65a8f85a1505d0a96212775b4ae0">computeVelCoeffsMtx</a> (int sectorOrder, float_complex *A_xyz)</td></tr>
<tr class="memdesc:acb1a65a8f85a1505d0a96212775b4ae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the matrices that generate the coefficients of the beampattern of order (sectorOrder+1) that is essentially the product of a pattern of order=sectorOrder and a dipole.  <a href="saf__sh_8h.html#acb1a65a8f85a1505d0a96212775b4ae0">More...</a><br /></td></tr>
<tr class="separator:acb1a65a8f85a1505d0a96212775b4ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a383baca216c2fa72fe1a7c5804133203"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__sh_8h.html#a383baca216c2fa72fe1a7c5804133203">computeSectorCoeffsEP</a> (int orderSec, float_complex *A_xyz, <a class="el" href="saf__sh_8h.html#a48746a72d4da48b8b442f5cdf76a378b">SECTOR_PATTERNS</a> pattern, float *sec_dirs_deg, int nSecDirs, float *sectorCoeffs)</td></tr>
<tr class="memdesc:a383baca216c2fa72fe1a7c5804133203"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the beamforming matrices of sector and velocity coefficients for ENERGY-preserving (EP) sectors for real SH.  <a href="saf__sh_8h.html#a383baca216c2fa72fe1a7c5804133203">More...</a><br /></td></tr>
<tr class="separator:a383baca216c2fa72fe1a7c5804133203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0e1b22dff2d98ed226851bbc2033144"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__sh_8h.html#ad0e1b22dff2d98ed226851bbc2033144">computeSectorCoeffsAP</a> (int orderSec, float_complex *A_xyz, <a class="el" href="saf__sh_8h.html#a48746a72d4da48b8b442f5cdf76a378b">SECTOR_PATTERNS</a> pattern, float *sec_dirs_deg, int nSecDirs, float *sectorCoeffs)</td></tr>
<tr class="memdesc:ad0e1b22dff2d98ed226851bbc2033144"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the beamforming matrices of sector and velocity coefficients for AMPLITUDE-preserving (AP) sectors for real SH.  <a href="saf__sh_8h.html#ad0e1b22dff2d98ed226851bbc2033144">More...</a><br /></td></tr>
<tr class="separator:ad0e1b22dff2d98ed226851bbc2033144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad01934dabcf7a8f8b08bcdd4439fe3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__sh_8h.html#a7ad01934dabcf7a8f8b08bcdd4439fe3">beamWeightsCardioid2Spherical</a> (int N, float *b_n)</td></tr>
<tr class="memdesc:a7ad01934dabcf7a8f8b08bcdd4439fe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates spherical coefficients for cardioids.  <a href="saf__sh_8h.html#a7ad01934dabcf7a8f8b08bcdd4439fe3">More...</a><br /></td></tr>
<tr class="separator:a7ad01934dabcf7a8f8b08bcdd4439fe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f95b52193c9d94633463106c86cb63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__sh_8h.html#a45f95b52193c9d94633463106c86cb63">beamWeightsDolphChebyshev2Spherical</a> (int N, int paramType, float arrayParam, float *b_n)</td></tr>
<tr class="memdesc:a45f95b52193c9d94633463106c86cb63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates beamweights in the SHD for Dolph-Chebyshev beampatterns, with mainlobe and sidelobe control [1].  <a href="saf__sh_8h.html#a45f95b52193c9d94633463106c86cb63">More...</a><br /></td></tr>
<tr class="separator:a45f95b52193c9d94633463106c86cb63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce9116273f897fe0ecf9b46d580be48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__sh_8h.html#a9ce9116273f897fe0ecf9b46d580be48">beamWeightsHypercardioid2Spherical</a> (int N, float *b_n)</td></tr>
<tr class="memdesc:a9ce9116273f897fe0ecf9b46d580be48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates beamweights in the SHD for hypercardioid beampatterns.  <a href="saf__sh_8h.html#a9ce9116273f897fe0ecf9b46d580be48">More...</a><br /></td></tr>
<tr class="separator:a9ce9116273f897fe0ecf9b46d580be48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c35ba6af7f1f13e53ee473bb622398b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__sh_8h.html#a7c35ba6af7f1f13e53ee473bb622398b">beamWeightsMaxEV</a> (int N, float *b_n)</td></tr>
<tr class="memdesc:a7c35ba6af7f1f13e53ee473bb622398b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates beamweights in the SHD for maximum energy-vector beampatterns.  <a href="saf__sh_8h.html#a7c35ba6af7f1f13e53ee473bb622398b">More...</a><br /></td></tr>
<tr class="separator:a7c35ba6af7f1f13e53ee473bb622398b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fcf376f908a5403bc31989ac986ab78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__sh_8h.html#a4fcf376f908a5403bc31989ac986ab78">beamWeightsVelocityPatternsReal</a> (int order, float *b_n, float azi_rad, float elev_rad, float_complex *A_xyz, float *velCoeffs)</td></tr>
<tr class="memdesc:a4fcf376f908a5403bc31989ac986ab78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates beamforming coefficients for velocity patterns (REAL)  <a href="saf__sh_8h.html#a4fcf376f908a5403bc31989ac986ab78">More...</a><br /></td></tr>
<tr class="separator:a4fcf376f908a5403bc31989ac986ab78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6077cbef3c4d075dd47e833f9675ae37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__sh_8h.html#a6077cbef3c4d075dd47e833f9675ae37">beamWeightsVelocityPatternsComplex</a> (int order, float *b_n, float azi_rad, float elev_rad, float_complex *A_xyz, float_complex *velCoeffs)</td></tr>
<tr class="memdesc:a6077cbef3c4d075dd47e833f9675ae37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates beamforming coefficients for velocity patterns (COMPLEX)  <a href="saf__sh_8h.html#a6077cbef3c4d075dd47e833f9675ae37">More...</a><br /></td></tr>
<tr class="separator:a6077cbef3c4d075dd47e833f9675ae37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a824b11467b1f54b0725264b256f6a193"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__sh_8h.html#a824b11467b1f54b0725264b256f6a193">rotateAxisCoeffsReal</a> (int order, float *c_n, float theta_0, float phi_0, float *c_nm)</td></tr>
<tr class="memdesc:a824b11467b1f54b0725264b256f6a193"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates spherical coefficients for a rotated axisymmetric pattern (REAL)  <a href="saf__sh_8h.html#a824b11467b1f54b0725264b256f6a193">More...</a><br /></td></tr>
<tr class="separator:a824b11467b1f54b0725264b256f6a193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a266a06c6c96240add2d3ab171d89925d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__sh_8h.html#a266a06c6c96240add2d3ab171d89925d">rotateAxisCoeffsComplex</a> (int order, float *c_n, float theta_0, float phi_0, float_complex *c_nm)</td></tr>
<tr class="memdesc:a266a06c6c96240add2d3ab171d89925d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates spherical coefficients for a rotated axisymmetric pattern (COMPLEX)  <a href="saf__sh_8h.html#a266a06c6c96240add2d3ab171d89925d">More...</a><br /></td></tr>
<tr class="separator:a266a06c6c96240add2d3ab171d89925d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add7fa820cb691a376c70ca33e1c77743"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__sh_8h.html#add7fa820cb691a376c70ca33e1c77743">checkCondNumberSHTReal</a> (int order, float *dirs_rad, int nDirs, float *w, float *cond_N)</td></tr>
<tr class="memdesc:add7fa820cb691a376c70ca33e1c77743"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the condition numbers for a least-squares SHT.  <a href="saf__sh_8h.html#add7fa820cb691a376c70ca33e1c77743">More...</a><br /></td></tr>
<tr class="separator:add7fa820cb691a376c70ca33e1c77743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6b1194ee375caef234c1302fddce718"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__sh_8h.html#ac6b1194ee375caef234c1302fddce718">generatePWDmap</a> (int order, float_complex *Cx, float_complex *Y_grid, int nGrid_dirs, float *pmap)</td></tr>
<tr class="memdesc:ac6b1194ee375caef234c1302fddce718"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a powermap based on the energy of plane-wave decomposition (PWD)/ hyper-cardioid beamformers.  <a href="saf__sh_8h.html#ac6b1194ee375caef234c1302fddce718">More...</a><br /></td></tr>
<tr class="separator:ac6b1194ee375caef234c1302fddce718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a623080053b63c3a918485dcba3e084"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__sh_8h.html#a0a623080053b63c3a918485dcba3e084">generateMVDRmap</a> (int order, float_complex *Cx, float_complex *Y_grid, int nGrid_dirs, float regPar, float *pmap, float_complex *w_MVDR)</td></tr>
<tr class="memdesc:a0a623080053b63c3a918485dcba3e084"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a powermap based on the energy of adaptive minimum variance distortion-less response (MVDR) beamformers.  <a href="saf__sh_8h.html#a0a623080053b63c3a918485dcba3e084">More...</a><br /></td></tr>
<tr class="separator:a0a623080053b63c3a918485dcba3e084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa06c99cc4846f8c2148a93db9086e54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__sh_8h.html#afa06c99cc4846f8c2148a93db9086e54">generateCroPaCLCMVmap</a> (int order, float_complex *Cx, float_complex *Y_grid, int nGrid_dirs, float regPar, float lambda, float *pmap)</td></tr>
<tr class="memdesc:afa06c99cc4846f8c2148a93db9086e54"><td class="mdescLeft">&#160;</td><td class="mdescRight">EXPERIMENTAL Generates a powermap utilising the CroPaC LCMV post-filter described in [1].  <a href="saf__sh_8h.html#afa06c99cc4846f8c2148a93db9086e54">More...</a><br /></td></tr>
<tr class="separator:afa06c99cc4846f8c2148a93db9086e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c430bacc593f41dbc7b0b1ba6c912cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__sh_8h.html#a9c430bacc593f41dbc7b0b1ba6c912cd">generateMUSICmap</a> (int order, float_complex *Cx, float_complex *Y_grid, int nSources, int nGrid_dirs, int logScaleFlag, float *pmap)</td></tr>
<tr class="memdesc:a9c430bacc593f41dbc7b0b1ba6c912cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates an activity-map based on the sub-space multiple-signal classification (MUSIC) method.  <a href="saf__sh_8h.html#a9c430bacc593f41dbc7b0b1ba6c912cd">More...</a><br /></td></tr>
<tr class="separator:a9c430bacc593f41dbc7b0b1ba6c912cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08d3bc0f9e750716e3fb73c1c3aafe6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__sh_8h.html#a08d3bc0f9e750716e3fb73c1c3aafe6e">generateMinNormMap</a> (int order, float_complex *Cx, float_complex *Y_grid, int nSources, int nGrid_dirs, int logScaleFlag, float *pmap)</td></tr>
<tr class="memdesc:a08d3bc0f9e750716e3fb73c1c3aafe6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates an activity-map based on the sub-space minimum-norm (MinNorm) method.  <a href="saf__sh_8h.html#a08d3bc0f9e750716e3fb73c1c3aafe6e">More...</a><br /></td></tr>
<tr class="separator:a08d3bc0f9e750716e3fb73c1c3aafe6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34663eefbf80e9df6c46243e5f21de67"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__sh_8h.html#a34663eefbf80e9df6c46243e5f21de67">bessel_Jn</a> (int N, double *z, int nZ, double *J_n, double *dJ_n)</td></tr>
<tr class="memdesc:a34663eefbf80e9df6c46243e5f21de67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the (cylindrical) Bessel function of the first kind: Jn.  <a href="saf__sh_8h.html#a34663eefbf80e9df6c46243e5f21de67">More...</a><br /></td></tr>
<tr class="separator:a34663eefbf80e9df6c46243e5f21de67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67f4ff2d969b3724f75eb48e31e91a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__sh_8h.html#ae67f4ff2d969b3724f75eb48e31e91a7">bessel_Yn</a> (int N, double *z, int nZ, double *Y_n, double *dY_n)</td></tr>
<tr class="memdesc:ae67f4ff2d969b3724f75eb48e31e91a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the (cylindrical) Bessel function of the second kind: Yn.  <a href="saf__sh_8h.html#ae67f4ff2d969b3724f75eb48e31e91a7">More...</a><br /></td></tr>
<tr class="separator:ae67f4ff2d969b3724f75eb48e31e91a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5212dd2d7d1c3e5428e0f58161fd618"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__sh_8h.html#ac5212dd2d7d1c3e5428e0f58161fd618">hankel_Hn1</a> (int N, double *z, int nZ, double_complex *Hn1_n, double_complex *dHn1_n)</td></tr>
<tr class="memdesc:ac5212dd2d7d1c3e5428e0f58161fd618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the (cylindrical) Hankel function of the first kind: Hn1.  <a href="saf__sh_8h.html#ac5212dd2d7d1c3e5428e0f58161fd618">More...</a><br /></td></tr>
<tr class="separator:ac5212dd2d7d1c3e5428e0f58161fd618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8767d46052f8be003ab60001d161fad3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__sh_8h.html#a8767d46052f8be003ab60001d161fad3">hankel_Hn2</a> (int N, double *z, int nZ, double_complex *Hn2_n, double_complex *dHn2_n)</td></tr>
<tr class="memdesc:a8767d46052f8be003ab60001d161fad3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the (cylindrical) Hankel function of the second kind: Hn2.  <a href="saf__sh_8h.html#a8767d46052f8be003ab60001d161fad3">More...</a><br /></td></tr>
<tr class="separator:a8767d46052f8be003ab60001d161fad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2621b74729df0c3480df268df93c6d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__sh_8h.html#aa2621b74729df0c3480df268df93c6d2">bessel_jn</a> (int N, double *z, int nZ, int *maxN, double *j_n, double *dj_n)</td></tr>
<tr class="memdesc:aa2621b74729df0c3480df268df93c6d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the spherical Bessel function of the first kind: jn.  <a href="saf__sh_8h.html#aa2621b74729df0c3480df268df93c6d2">More...</a><br /></td></tr>
<tr class="separator:aa2621b74729df0c3480df268df93c6d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3d6e2f3eef8cc0cf2f93fef693446c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__sh_8h.html#aa3d6e2f3eef8cc0cf2f93fef693446c4">bessel_in</a> (int N, double *z, int nZ, int *maxN, double *i_n, double *di_n)</td></tr>
<tr class="memdesc:aa3d6e2f3eef8cc0cf2f93fef693446c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the modified spherical Bessel function of the first kind: in.  <a href="saf__sh_8h.html#aa3d6e2f3eef8cc0cf2f93fef693446c4">More...</a><br /></td></tr>
<tr class="separator:aa3d6e2f3eef8cc0cf2f93fef693446c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa03183e136f8f2fe053e97778707ea5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__sh_8h.html#aa03183e136f8f2fe053e97778707ea5f">bessel_yn</a> (int N, double *z, int nZ, int *maxN, double *y_n, double *dy_n)</td></tr>
<tr class="memdesc:aa03183e136f8f2fe053e97778707ea5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the spherical Bessel function of the second kind (Neumann): yn.  <a href="saf__sh_8h.html#aa03183e136f8f2fe053e97778707ea5f">More...</a><br /></td></tr>
<tr class="separator:aa03183e136f8f2fe053e97778707ea5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9929b3494ce7831d8ec455963c32b3b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__sh_8h.html#a9929b3494ce7831d8ec455963c32b3b7">bessel_kn</a> (int N, double *z, int nZ, int *maxN, double *k_n, double *dk_n)</td></tr>
<tr class="memdesc:a9929b3494ce7831d8ec455963c32b3b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the modified spherical Bessel function of the second kind: kn.  <a href="saf__sh_8h.html#a9929b3494ce7831d8ec455963c32b3b7">More...</a><br /></td></tr>
<tr class="separator:a9929b3494ce7831d8ec455963c32b3b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cd43009e3663f71077e327ef8b1c3f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__sh_8h.html#a0cd43009e3663f71077e327ef8b1c3f5">hankel_hn1</a> (int N, double *z, int nZ, int *maxN, double_complex *h_n1, double_complex *dh_n1)</td></tr>
<tr class="memdesc:a0cd43009e3663f71077e327ef8b1c3f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the spherical Hankel function of the first kind: hn1.  <a href="saf__sh_8h.html#a0cd43009e3663f71077e327ef8b1c3f5">More...</a><br /></td></tr>
<tr class="separator:a0cd43009e3663f71077e327ef8b1c3f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a594732d5b9ef92efc01ac73b8e73bfac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__sh_8h.html#a594732d5b9ef92efc01ac73b8e73bfac">hankel_hn2</a> (int N, double *z, int nZ, int *maxN, double_complex *h_n2, double_complex *dh_n2)</td></tr>
<tr class="memdesc:a594732d5b9ef92efc01ac73b8e73bfac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the spherical Hankel function of the second kind: hn2.  <a href="saf__sh_8h.html#a594732d5b9ef92efc01ac73b8e73bfac">More...</a><br /></td></tr>
<tr class="separator:a594732d5b9ef92efc01ac73b8e73bfac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c63d4e98e234ed80ba8eca7f939b653"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__sh_8h.html#a2c63d4e98e234ed80ba8eca7f939b653">cylModalCoeffs</a> (int order, double *kr, int nBands, <a class="el" href="saf__sh_8h.html#a89fc3daef304221a6826fd6916396e5f">ARRAY_CONSTRUCTION_TYPES</a> arrayType, double_complex *b_N)</td></tr>
<tr class="memdesc:a2c63d4e98e234ed80ba8eca7f939b653"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the modal coefficients for open/rigid cylindrical arrays.  <a href="saf__sh_8h.html#a2c63d4e98e234ed80ba8eca7f939b653">More...</a><br /></td></tr>
<tr class="separator:a2c63d4e98e234ed80ba8eca7f939b653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a898eab67c2144d794201bbc80c2c6aa2"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__sh_8h.html#a898eab67c2144d794201bbc80c2c6aa2">sphArrayAliasLim</a> (float r, float c, int maxN)</td></tr>
<tr class="memdesc:a898eab67c2144d794201bbc80c2c6aa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a simple estimate of the spatial aliasing limit (the kR = maxN rule)  <a href="saf__sh_8h.html#a898eab67c2144d794201bbc80c2c6aa2">More...</a><br /></td></tr>
<tr class="separator:a898eab67c2144d794201bbc80c2c6aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9774e448be3d0caf15ce45077d0d5ebe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__sh_8h.html#a9774e448be3d0caf15ce45077d0d5ebe">sphArrayNoiseThreshold</a> (int maxN, int Nsensors, float r, float c, <a class="el" href="saf__sh_8h.html#a89fc3daef304221a6826fd6916396e5f">ARRAY_CONSTRUCTION_TYPES</a> arrayType, double dirCoeff, float maxG_db, float *f_lim)</td></tr>
<tr class="memdesc:a9774e448be3d0caf15ce45077d0d5ebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the frequncies (per order), at which the noise of a SHT of a SMA exceeds a specified maximum level.  <a href="saf__sh_8h.html#a9774e448be3d0caf15ce45077d0d5ebe">More...</a><br /></td></tr>
<tr class="separator:a9774e448be3d0caf15ce45077d0d5ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c331fd73b56845ab0ecbf4b0d5fc640"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__sh_8h.html#a6c331fd73b56845ab0ecbf4b0d5fc640">sphModalCoeffs</a> (int order, double *kr, int nBands, <a class="el" href="saf__sh_8h.html#a89fc3daef304221a6826fd6916396e5f">ARRAY_CONSTRUCTION_TYPES</a> arrayType, double dirCoeff, double_complex *b_N)</td></tr>
<tr class="memdesc:a6c331fd73b56845ab0ecbf4b0d5fc640"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the modal coefficients for open/rigid spherical arrays.  <a href="saf__sh_8h.html#a6c331fd73b56845ab0ecbf4b0d5fc640">More...</a><br /></td></tr>
<tr class="separator:a6c331fd73b56845ab0ecbf4b0d5fc640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc74c9714841c3f48974fe10e6485eea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__sh_8h.html#adc74c9714841c3f48974fe10e6485eea">sphScattererModalCoeffs</a> (int order, double *kr, double *kR, int nBands, double_complex *b_N)</td></tr>
<tr class="memdesc:adc74c9714841c3f48974fe10e6485eea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the modal coefficients for a rigid spherical scatterer with omni-directional sensors.  <a href="saf__sh_8h.html#adc74c9714841c3f48974fe10e6485eea">More...</a><br /></td></tr>
<tr class="separator:adc74c9714841c3f48974fe10e6485eea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc488e33c0239baebed8cd7aeabd8a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__sh_8h.html#aedc488e33c0239baebed8cd7aeabd8a7">sphScattererDirModalCoeffs</a> (int order, double *kr, double *kR, int nBands, double dirCoeff, double_complex *b_N)</td></tr>
<tr class="memdesc:aedc488e33c0239baebed8cd7aeabd8a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the modal coefficients for a rigid spherical scatterer with directional sensors.  <a href="saf__sh_8h.html#aedc488e33c0239baebed8cd7aeabd8a7">More...</a><br /></td></tr>
<tr class="separator:aedc488e33c0239baebed8cd7aeabd8a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3c0a54aacdd607e5d305db0e362cfce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__sh_8h.html#ac3c0a54aacdd607e5d305db0e362cfce">sphDiffCohMtxTheory</a> (int order, float *sensor_dirs_rad, int N_sensors, <a class="el" href="saf__sh_8h.html#a89fc3daef304221a6826fd6916396e5f">ARRAY_CONSTRUCTION_TYPES</a> arrayType, double dirCoeff, double *kr, double *kR, int nBands, double *M_diffcoh)</td></tr>
<tr class="memdesc:ac3c0a54aacdd607e5d305db0e362cfce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the theoretical diffuse coherence matrix for a spherical array.  <a href="saf__sh_8h.html#ac3c0a54aacdd607e5d305db0e362cfce">More...</a><br /></td></tr>
<tr class="separator:ac3c0a54aacdd607e5d305db0e362cfce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5203b16cf67ef27b422078d20618863"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__sh_8h.html#aa5203b16cf67ef27b422078d20618863">simulateCylArray</a> (int order, double *kr, int nBands, float *sensor_dirs_rad, int N_sensors, float *src_dirs_deg, int N_srcs, <a class="el" href="saf__sh_8h.html#a89fc3daef304221a6826fd6916396e5f">ARRAY_CONSTRUCTION_TYPES</a> arrayType, float_complex *H_array)</td></tr>
<tr class="memdesc:aa5203b16cf67ef27b422078d20618863"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simulates a cylindrical microphone array, returning the transfer functions for each (plane wave) source direction on the surface of the cylinder.  <a href="saf__sh_8h.html#aa5203b16cf67ef27b422078d20618863">More...</a><br /></td></tr>
<tr class="separator:aa5203b16cf67ef27b422078d20618863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4fe5085d4cc6223772f6e49ef74f355"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__sh_8h.html#ab4fe5085d4cc6223772f6e49ef74f355">simulateSphArray</a> (int order, double *kr, double *kR, int nBands, float *sensor_dirs_rad, int N_sensors, float *src_dirs_deg, int N_srcs, <a class="el" href="saf__sh_8h.html#a89fc3daef304221a6826fd6916396e5f">ARRAY_CONSTRUCTION_TYPES</a> arrayType, double dirCoeff, float_complex *H_array)</td></tr>
<tr class="memdesc:ab4fe5085d4cc6223772f6e49ef74f355"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simulates a spherical microphone array, returning the transfer functions for each (plane wave) source direction on the surface of the sphere.  <a href="saf__sh_8h.html#ab4fe5085d4cc6223772f6e49ef74f355">More...</a><br /></td></tr>
<tr class="separator:ab4fe5085d4cc6223772f6e49ef74f355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e7f439e15ed96ccf49617ba763ca4b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__sh_8h.html#a2e7f439e15ed96ccf49617ba763ca4b6">evaluateSHTfilters</a> (int order, float_complex *M_array2SH, int nSensors, int nBands, float_complex *H_array, int nDirs, float_complex *Y_grid, float *cSH, float *lSH)</td></tr>
<tr class="memdesc:a2e7f439e15ed96ccf49617ba763ca4b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates some objective measures, which evaluate the performance of the spatial encoding filters.  <a href="saf__sh_8h.html#a2e7f439e15ed96ccf49617ba763ca4b6">More...</a><br /></td></tr>
<tr class="separator:a2e7f439e15ed96ccf49617ba763ca4b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Public part of the "saf_sh" module. </p>
<p>A collection of spherical harmonic related functions. Many of which have been derived from Matlab libraries by Archontis Politis [1-3].</p>
<dl class="section see"><dt>See also</dt><dd>[1] <a href="https://github.com/polarch/Spherical-Harmonic-Transform">https://github.com/polarch/Spherical-Harmonic-Transform</a> </dd>
<dd>
[2] <a href="https://github.com/polarch/Array-Response-Simulator">https://github.com/polarch/Array-Response-Simulator</a> </dd>
<dd>
[3] <a href="https://github.com/polarch/Spherical-Array-Processing">https://github.com/polarch/Spherical-Array-Processing</a></dd></dl>
<dl class="section author"><dt>Author</dt><dd>Leo McCormack </dd></dl>
<dl class="section date"><dt>Date</dt><dd>22.05.2016 </dd></dl>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a48746a72d4da48b8b442f5cdf76a378b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48746a72d4da48b8b442f5cdf76a378b">&#9670;&nbsp;</a></span>SECTOR_PATTERNS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="saf__sh_8h.html#a3e5dc1652d5020b211a8d9cf570e6052">_SECTOR_PATTERNS</a> <a class="el" href="saf__sh_8h.html#a48746a72d4da48b8b442f5cdf76a378b">SECTOR_PATTERNS</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sector pattern designs for directionally-contraining sound-fields [1]. </p>
<dl class="section see"><dt>See also</dt><dd>[1] Politis, A., &amp; Pulkki, V. (2016). Acoustic intensity, energy-density and diffuseness estimation in a directionally-constrained region. arXiv preprint arXiv:1609.03409 </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a6f72ce94d4f31c672211e7b98390d45a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f72ce94d4f31c672211e7b98390d45a">&#9670;&nbsp;</a></span>_ARRAY_CONSTRUCTION_TYPES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="saf__sh_8h.html#a6f72ce94d4f31c672211e7b98390d45a">_ARRAY_CONSTRUCTION_TYPES</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Microphone/Hydrophone array contruction types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6f72ce94d4f31c672211e7b98390d45aaef2926e644b5529e6673d9af8cc5b0a1"></a>ARRAY_CONSTRUCTION_OPEN&#160;</td><td class="fielddoc"><p>Open array, omni-directional sensors. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6f72ce94d4f31c672211e7b98390d45aadd3f9c2386004df3244de2912dcdf496"></a>ARRAY_CONSTRUCTION_OPEN_DIRECTIONAL&#160;</td><td class="fielddoc"><p>Open array, directional sensors. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6f72ce94d4f31c672211e7b98390d45aa5b24de1a578a08282bebacdf03cefa7d"></a>ARRAY_CONSTRUCTION_RIGID&#160;</td><td class="fielddoc"><p>Rigid baffle, omni-directional sensors. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6f72ce94d4f31c672211e7b98390d45aa046ccc1a8e502c8c952bb745def379b0"></a>ARRAY_CONSTRUCTION_RIGID_DIRECTIONAL&#160;</td><td class="fielddoc"><p>Rigid baffle, directional sensors. </p>
</td></tr>
</table>

</div>
</div>
<a id="a3e5dc1652d5020b211a8d9cf570e6052"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e5dc1652d5020b211a8d9cf570e6052">&#9670;&nbsp;</a></span>_SECTOR_PATTERNS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="saf__sh_8h.html#a3e5dc1652d5020b211a8d9cf570e6052">_SECTOR_PATTERNS</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sector pattern designs for directionally-contraining sound-fields [1]. </p>
<dl class="section see"><dt>See also</dt><dd>[1] Politis, A., &amp; Pulkki, V. (2016). Acoustic intensity, energy-density and diffuseness estimation in a directionally-constrained region. arXiv preprint arXiv:1609.03409 </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a3e5dc1652d5020b211a8d9cf570e6052a0ee77a29b6b553c6965108d240f99ff7"></a>SECTOR_PATTERN_PWD&#160;</td><td class="fielddoc"><p>Plane-wave decomposition/Hyper-cardioid. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3e5dc1652d5020b211a8d9cf570e6052a9024988fa2c043c931936b0e4fae3055"></a>SECTOR_PATTERN_MAXRE&#160;</td><td class="fielddoc"><p>Spatially tapered hyper-cardioid, such that it has maximum energy concentrated in the look- direction. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3e5dc1652d5020b211a8d9cf570e6052aa419a9e82484c4077a49ab1a4bdbe30f"></a>SECTOR_PATTERN_CARDIOID&#160;</td><td class="fielddoc"><p>Cardioid pattern. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a7ad01934dabcf7a8f8b08bcdd4439fe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ad01934dabcf7a8f8b08bcdd4439fe3">&#9670;&nbsp;</a></span>beamWeightsCardioid2Spherical()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void beamWeightsCardioid2Spherical </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>b_n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates spherical coefficients for cardioids. </p>
<p>For a specific order N of a higher order cardioid of the form D(theta)=(1/2)^N * (1+cos(theta))^N, generate the beamweights for the same pattern in the SHD. Because the pattern is axisymmetric only the N+1 coefficients of m=0 are returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>Order of spherical harmonic expansion </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">b_n</td><td>Beamformer weights; (N+1) x 1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a45f95b52193c9d94633463106c86cb63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45f95b52193c9d94633463106c86cb63">&#9670;&nbsp;</a></span>beamWeightsDolphChebyshev2Spherical()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void beamWeightsDolphChebyshev2Spherical </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>paramType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>arrayParam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>b_n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates beamweights in the SHD for Dolph-Chebyshev beampatterns, with mainlobe and sidelobe control [1]. </p>
<p>Because the pattern is axisymmetric only the N+1 coefficients of m=0 are returned.</p>
<dl class="section note"><dt>Note</dt><dd>NOT IMPLEMENTED YET</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>Order of spherical harmonic expansion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">paramType</td><td>'0' side-lobe level control, '1' mainlobe width control </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arrayParam</td><td>Sidelobe level 1/R or mainlobe with 2*a0 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">b_n</td><td>Beamformer weights; (N+1) x 1</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>[1] Koretz, A. and Rafaely, B., 2009. Dolph-Chebyshev beampattern design for spherical arrays. IEEE Transactions on Signal Processing, 57(6), pp.2417-2420. </dd></dl>

</div>
</div>
<a id="a9ce9116273f897fe0ecf9b46d580be48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ce9116273f897fe0ecf9b46d580be48">&#9670;&nbsp;</a></span>beamWeightsHypercardioid2Spherical()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void beamWeightsHypercardioid2Spherical </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>b_n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates beamweights in the SHD for hypercardioid beampatterns. </p>
<p>The hypercardioid is the pattern that maximises the directivity-factor for a certain SH order N. The hypercardioid is also the plane-wave decomposition beamformer in the SHD, also called 'regular' because the beamweights are just the SH values on the beam-direction. Since the pattern is axisymmetric only the N+1 coefficients of m=0 are returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>Order of spherical harmonic expansion </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">b_n</td><td>Beamformer weights; (N+1) x 1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7c35ba6af7f1f13e53ee473bb622398b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c35ba6af7f1f13e53ee473bb622398b">&#9670;&nbsp;</a></span>beamWeightsMaxEV()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void beamWeightsMaxEV </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>b_n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates beamweights in the SHD for maximum energy-vector beampatterns. </p>
<p>Generate the beamweights for the a maximum energy-vector beampattern in the SHD. This pattern originates from ambisonic-related research and it maximises the ambisonic energy-vector, which is essentially the directional centroid of the squared pattern. IT can also be seen as the pattern that maximizes the acoustic intensity vector of a diffuse field weighted with this pattern. In practice it is almost the same as a supercardioid that maximizes front- back power ratio for a certain order, and it can be used as such. Because the pattern is axisymmetric only the N+1 coefficients of m=0 are returned. Details for their theory can be found e.g. in [1].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>Order of spherical harmonic expansion </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">b_n</td><td>Beamformer weights; (N+1) x 1</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>[1] Zotter, F., Pomberger, H. and Noisternig, M., 2012. Energy- preserving ambisonic decoding. Acta Acustica united with Acustica, 98(1), pp.37-47. </dd></dl>

</div>
</div>
<a id="a6077cbef3c4d075dd47e833f9675ae37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6077cbef3c4d075dd47e833f9675ae37">&#9670;&nbsp;</a></span>beamWeightsVelocityPatternsComplex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void beamWeightsVelocityPatternsComplex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>b_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>azi_rad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>elev_rad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>A_xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>velCoeffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates beamforming coefficients for velocity patterns (COMPLEX) </p>
<p>If the sound-field is weighted with an axisymmetric spatial distribution described by the N+1 SH coefficients b_n, then the beamweights capturing the velocity signals for the weighted sound-field are of an order one higher than the weighting pattern, and can be derived from it. This type of beamforming has some applications for spatial sound reproduction and acoustic analysis, see [1].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Order of spherical harmonic expansion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b_n</td><td>Axisymmetric beamformer weights; (order+1) x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">azi_rad</td><td>Orientation, azimuth in RADIANS </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elev_rad</td><td>Orientation, ELEVATION in RADIANS </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A_xyz</td><td>Velocity coefficients (see "computeVelCoeffsMtx"); FLAT: (sectorOrder+2)^2 x (sectorOrder+1)^2 x 3 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">velCoeffs</td><td>Beamforming coefficients for velocity patterns; FLAT: (order+2)^2 x 3</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>[1] Politis, A. and Pulkki, V., 2016. Acoustic intensity, energy-density and diffuseness estimation in a directionally-constrained region. arXiv preprint arXiv:1609.03409. </dd></dl>

</div>
</div>
<a id="a4fcf376f908a5403bc31989ac986ab78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fcf376f908a5403bc31989ac986ab78">&#9670;&nbsp;</a></span>beamWeightsVelocityPatternsReal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void beamWeightsVelocityPatternsReal </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>b_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>azi_rad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>elev_rad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>A_xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>velCoeffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates beamforming coefficients for velocity patterns (REAL) </p>
<p>If the sound-field is weighted with an axisymmetric spatial distribution described by the N+1 SH coefficients b_n, then the beamweights capturing the velocity signals for the weighted sound-field are of an order one higher than the weighting pattern, and can be derived from it. This type of beamforming has some applications for spatial sound reproduction and acoustic analysis, see [1].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Order of spherical harmonic expansion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b_n</td><td>Axisymmetric beamformer weights; (order+1) x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">azi_rad</td><td>Orientation, azimuth in RADIANS </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elev_rad</td><td>Orientation, ELEVATION in RADIANS </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A_xyz</td><td>Velocity coefficients (see "computeVelCoeffsMtx"); FLAT: (sectorOrder+2)^2 x (sectorOrder+1)^2 x 3 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">velCoeffs</td><td>Beamforming coefficients for velocity patterns; FLAT: (order+2)^2 x 3</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>[1] Politis, A. and Pulkki, V., 2016. Acoustic intensity, energy-density and diffuseness estimation in a directionally-constrained region. arXiv preprint arXiv:1609.03409. </dd></dl>

</div>
</div>
<a id="aa3d6e2f3eef8cc0cf2f93fef693446c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3d6e2f3eef8cc0cf2f93fef693446c4">&#9670;&nbsp;</a></span>bessel_in()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bessel_in </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>maxN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>i_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>di_n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the modified spherical Bessel function of the first kind: in. </p>
<p>Computes the Bessel values and their derivatives up to order N for all values in vector z</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>Function order (highest is ~30 given numerical precision) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z</td><td>Input values; nZ x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nZ</td><td>Number of input values </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">maxN</td><td>(&amp;) maximum function order that could be computed &lt;=N </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">i_n</td><td>Bessel values (set as NULL if not required); FLAT: nZ x (N+1) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">di_n</td><td>Bessel derivative values (set as NULL if not required); FLAT: nZ x (N+1) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a34663eefbf80e9df6c46243e5f21de67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34663eefbf80e9df6c46243e5f21de67">&#9670;&nbsp;</a></span>bessel_Jn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bessel_Jn </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>J_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>dJ_n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the (cylindrical) Bessel function of the first kind: Jn. </p>
<p>Computes the Bessel values and their derivatives up to order N for all values in vector z</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>Function order (highest is ~30 given numerical precision) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z</td><td>Input values; nZ x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nZ</td><td>Number of input values </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">J_n</td><td>Bessel values (set as NULL if not required); FLAT: nZ x (N+1) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dJ_n</td><td>Bessel derivative values (set as NULL if not required); FLAT: nZ x (N+1) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa2621b74729df0c3480df268df93c6d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2621b74729df0c3480df268df93c6d2">&#9670;&nbsp;</a></span>bessel_jn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bessel_jn </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>maxN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>j_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>dj_n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the spherical Bessel function of the first kind: jn. </p>
<p>Computes the Bessel values and their derivatives up to order N for all values in vector z</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>Function order (highest is ~30 given numerical precision) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z</td><td>Input values; nZ x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nZ</td><td>Number of input values </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">maxN</td><td>(&amp;) maximum function order that could be computed &lt;=N </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">j_n</td><td>Bessel values (set as NULL if not required); FLAT: nZ x (N+1) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dj_n</td><td>Bessel derivative values (set as NULL if not required); FLAT: nZ x (N+1) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9929b3494ce7831d8ec455963c32b3b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9929b3494ce7831d8ec455963c32b3b7">&#9670;&nbsp;</a></span>bessel_kn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bessel_kn </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>maxN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>k_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>dk_n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the modified spherical Bessel function of the second kind: kn. </p>
<p>Computes the Bessel values and their derivatives up to order N for all values in vector z</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>Function order (highest is ~30 given numerical precision) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z</td><td>Input values; nZ x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nZ</td><td>Number of input values </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">maxN</td><td>(&amp;) maximum function order that could be computed &lt;=N </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">k_n</td><td>Bessel values (set as NULL if not required); FLAT: nZ x (N+1) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dk_n</td><td>Bessel derivative values (set as NULL if not required); FLAT: nZ x (N+1) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae67f4ff2d969b3724f75eb48e31e91a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae67f4ff2d969b3724f75eb48e31e91a7">&#9670;&nbsp;</a></span>bessel_Yn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bessel_Yn </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>Y_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>dY_n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the (cylindrical) Bessel function of the second kind: Yn. </p>
<p>Computes the Bessel values and their derivatives up to order N for all values in vector z</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>Function order (highest is ~30 given numerical precision) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z</td><td>Input values; nZ x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nZ</td><td>Number of input values </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Y_n</td><td>Bessel values (set as NULL if not required); FLAT: nZ x (N+1) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dY_n</td><td>Bessel derivative values (set as NULL if not required); FLAT: nZ x (N+1) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa03183e136f8f2fe053e97778707ea5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa03183e136f8f2fe053e97778707ea5f">&#9670;&nbsp;</a></span>bessel_yn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bessel_yn </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>maxN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>y_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>dy_n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the spherical Bessel function of the second kind (Neumann): yn. </p>
<p>Computes the Bessel values and their derivatives up to order N for all values in vector z</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>Function order (highest is ~30 given numerical precision) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z</td><td>Input values; nZ x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nZ</td><td>Number of input values </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">maxN</td><td>(&amp;) maximum function order that could be computed &lt;=N </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">y_n</td><td>Bessel values (set as NULL if not required); FLAT: nZ x (N+1) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dy_n</td><td>Bessel derivative values (set as NULL if not required); FLAT: nZ x (N+1) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="add7fa820cb691a376c70ca33e1c77743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add7fa820cb691a376c70ca33e1c77743">&#9670;&nbsp;</a></span>checkCondNumberSHTReal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void checkCondNumberSHTReal </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>dirs_rad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nDirs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>cond_N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the condition numbers for a least-squares SHT. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Order of spherical harmonic expansion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dirs_rad</td><td>Directions on the sphere [azi, INCLINATION] convention, in RADIANS; FLAT: nDirs x 2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nDirs</td><td>Number of directions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">w</td><td>Integration weights; nDirs x 1 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cond_N</td><td>Condition numbers; (order+1) x 1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa25c6081b6abb92ca3545a879b9996e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa25c6081b6abb92ca3545a879b9996e4">&#9670;&nbsp;</a></span>complex2realCoeffs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void complex2realCoeffs </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>C_N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>R_N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts SH coefficients from the complex to real basis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Order of spherical harmonic expansion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C_N</td><td>Complex coeffients; FLAT: (order+1)^2 x K </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">K</td><td>Number of columns </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">R_N</td><td>Real coefficients; FLAT: (order+1)^2 x K </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8bf53b93c2ccb874ee75088b769fb387"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bf53b93c2ccb874ee75088b769fb387">&#9670;&nbsp;</a></span>complex2realSHMtx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void complex2realSHMtx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>T_c2r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a complex to real spherical harmonic transform matrix. </p>
<p>Computes the unitary transformation matrix T_c2r. It expresses the real spherical harmonics with respect to the complex ones, so that r_N = T_c2r * y_N, where r_N and y_N is are the real and complex SH vectors, respectively.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Order of spherical harmonic expansion </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">T_c2r</td><td>Transformation matrix for complex-&gt;real; FLAT: (order+1)^2 x (order+1)^2 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad0e1b22dff2d98ed226851bbc2033144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0e1b22dff2d98ed226851bbc2033144">&#9670;&nbsp;</a></span>computeSectorCoeffsAP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float computeSectorCoeffsAP </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>orderSec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>A_xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="saf__sh_8h.html#a48746a72d4da48b8b442f5cdf76a378b">SECTOR_PATTERNS</a>&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>sec_dirs_deg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nSecDirs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>sectorCoeffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the beamforming matrices of sector and velocity coefficients for AMPLITUDE-preserving (AP) sectors for real SH. </p>
<p>This partitioning of the sound-field into spatially-localised sectors has been used for parametric sound-field reproduction in [1] and visualision in [2].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sectorOrder</td><td>Order of sector patterns </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A_xyz</td><td>Velocity coefficients (see "computeVelCoeffsMtx"); FLAT: (sectorOrder+2)^2 x (sectorOrder+1)^2 x 3 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pattern</td><td>See "SECTOR_PATTERNS" enum for the options </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sec_dirs_deg</td><td>Sector directions [azi elev], in DEGREES; FLAT: nSecDirs x 2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nSecDirs</td><td>Number of sectors </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sectorCoeffs</td><td>The sector coefficients; FLAT: (nSecDirs*4) x (orderSec+2)^2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>normalisation coefficient</dd></dl>
<dl class="section see"><dt>See also</dt><dd>[1] Politis, A., Vilkamo, J., &amp; Pulkki, V. (2015). Sector-based parametric sound field reproduction in the spherical harmonic domain. IEEE Journal of Selected Topics in Signal Processing, 9(5), 852-866. </dd>
<dd>
[2] McCormack, L., Politis, A., and Pulkki, V. (2019). "Sharpening of angular spectra based on a directional re-assignment approach for ambisonic sound-field visualisation". IEEE International Conference on Acoustics, Speech and Signal Processing (ICASSP). </dd></dl>

</div>
</div>
<a id="a383baca216c2fa72fe1a7c5804133203"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a383baca216c2fa72fe1a7c5804133203">&#9670;&nbsp;</a></span>computeSectorCoeffsEP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float computeSectorCoeffsEP </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>orderSec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>A_xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="saf__sh_8h.html#a48746a72d4da48b8b442f5cdf76a378b">SECTOR_PATTERNS</a>&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>sec_dirs_deg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nSecDirs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>sectorCoeffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the beamforming matrices of sector and velocity coefficients for ENERGY-preserving (EP) sectors for real SH. </p>
<p>This partitioning of the sound-field into spatially-localised sectors has been used for parametric sound-field reproduction in [1] and visualisation in [2].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sectorOrder</td><td>Order of sector patterns </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A_xyz</td><td>Velocity coefficients (see "computeVelCoeffsMtx"); FLAT: (sectorOrder+2)^2 x (sectorOrder+1)^2 x 3 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pattern</td><td>See "SECTOR_PATTERNS" enum for the options </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sec_dirs_deg</td><td>Sector directions [azi elev], in DEGREES; FLAT: nSecDirs x 2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nSecDirs</td><td>Number of sectors </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sectorCoeffs</td><td>The sector coefficients; FLAT: (nSecDirs*4) x (orderSec+2)^2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>normalisation coefficient</dd></dl>
<dl class="section see"><dt>See also</dt><dd>[1] Politis, A., Vilkamo, J., &amp; Pulkki, V. (2015). Sector-based parametric sound field reproduction in the spherical harmonic domain. IEEE Journal of Selected Topics in Signal Processing, 9(5), 852-866. </dd>
<dd>
[2] McCormack, L., Politis, A., and Pulkki, V. (2019). "Sharpening of angular spectra based on a directional re-assignment approach for ambisonic sound-field visualisation". IEEE International Conference ' on Acoustics, Speech and Signal Processing (ICASSP). </dd></dl>

</div>
</div>
<a id="acb1a65a8f85a1505d0a96212775b4ae0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb1a65a8f85a1505d0a96212775b4ae0">&#9670;&nbsp;</a></span>computeVelCoeffsMtx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void computeVelCoeffsMtx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sectorOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>A_xyz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the matrices that generate the coefficients of the beampattern of order (sectorOrder+1) that is essentially the product of a pattern of order=sectorOrder and a dipole. </p>
<p>It is used in "beamWeightsVelocityPatterns". For the derivation of the matrices see [1].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sectorOrder</td><td>Order of patterns </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A_xyz</td><td>Velocity coefficients; FLAT: (sectorOrder+2)^2 x (sectorOrder+1)^2 x 3</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>[1] Politis, A. and Pulkki, V., 2016. Acoustic intensity, energy-density and diffuseness estimation in a directionally-constrained region. arXiv preprint arXiv:1609.03409 </dd></dl>

</div>
</div>
<a id="a2c63d4e98e234ed80ba8eca7f939b653"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c63d4e98e234ed80ba8eca7f939b653">&#9670;&nbsp;</a></span>cylModalCoeffs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cylModalCoeffs </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>kr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nBands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="saf__sh_8h.html#a89fc3daef304221a6826fd6916396e5f">ARRAY_CONSTRUCTION_TYPES</a>&#160;</td>
          <td class="paramname"><em>arrayType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double_complex *&#160;</td>
          <td class="paramname"><em>b_N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the modal coefficients for open/rigid cylindrical arrays. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Max order (highest is ~30 given numerical precision) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kr</td><td>wavenumber*radius; nBands x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nBands</td><td>Number of frequency bands/bins </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arrayType</td><td>See 'ARRAY_CONSTRUCTION_TYPES' enum </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">b_N</td><td>Modal coefficients per kr and 0:order; FLAT: nBands x (order+1) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e7f439e15ed96ccf49617ba763ca4b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e7f439e15ed96ccf49617ba763ca4b6">&#9670;&nbsp;</a></span>evaluateSHTfilters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evaluateSHTfilters </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>M_array2SH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nSensors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nBands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>H_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nDirs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>Y_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>cSH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>lSH</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates some objective measures, which evaluate the performance of the spatial encoding filters. </p>
<p>This analysis is performed by comparing the spatial resolution of the spherical harmonic components generated by the encoding filters, with the ideal SH components. For more information, the reader is directed to [1,2].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Transform/encoding order </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M_array2SH</td><td>Encoding matrix per frequency; FLAT: nBands x (order+1)^2 x nSensors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nSensors</td><td>Number of sensors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nBands</td><td>Number of frequency bands/bins </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">H_array</td><td>Measured/modelled array responses for many directions; FLAT: nBands x nSensors x nDirs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nDirs</td><td>Number of directions the array was measured/modelled </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Y_grid</td><td>Spherical harmonics weights for each grid direction; FLAT: nDirs x (order+1)^2 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cSH</td><td>Absolute values of the spatial correlation per band and order; FLAT: nBands x (order+1) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lSH</td><td>Level difference per band and order; FLAT: nBands x (order+1)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>[1] Moreau, S., Daniel, J., Bertet, S., 2006, 3D sound field recording with higher order ambisonics-objective measurements and validation of spherical microphone. In Audio Engineering Society Convention 120. </dd>
<dd>
[2] Politis, A., Gamper, H. (2017). "Comparing Modelled And Measurement- Based Spherical Harmonic Encoding Filters For Spherical Microphone Arrays. In IEEE Workshop on Applications of Signal Processing to Audio and Acoustics (WASPAA). </dd></dl>

</div>
</div>
<a id="afa06c99cc4846f8c2148a93db9086e54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa06c99cc4846f8c2148a93db9086e54">&#9670;&nbsp;</a></span>generateCroPaCLCMVmap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void generateCroPaCLCMVmap </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>Cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>Y_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nGrid_dirs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>regPar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pmap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>EXPERIMENTAL Generates a powermap utilising the CroPaC LCMV post-filter described in [1]. </p>
<p>The spatial post-filter is estimated for all directions on the grid, and is used to supress reverb/noise interference that may be present in an MVDR map. Unlike in the paper, the second column for the contraints 'A', is Y.*diag(Cx), rather than utilising a maximum energy beamformer. The post- filters are then applied to the MVDR powermap map derived in the sherical harmonic domain, rather than an MVDR beamformer generated directly in the microphone array signal domain, like in the paper. Otherwise, the algorithm is the same.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Analysis order </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Cx</td><td>Correlation/covarience matrix; FLAT: (order+1)^2 x (order+1)^2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Y_grid</td><td>Steering vectors for each grid direcionts; FLAT: (order+1)^2 x nGrid_dirs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nGrid_dirs</td><td>Number of grid directions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">regPar</td><td>Regularisation parameter, for diagonal loading of Cx </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lambda</td><td>Parameter controlling how harsh CroPaC is applied, 0..1; 0: fully CroPaC, 1: fully MVDR </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pmap</td><td>Resulting CroPaC LCMV powermap; nGrid_dirs x 1</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>[1] Delikaris-Manias, S., Vilkamo, J., &amp; Pulkki, V. (2016). Signal- dependent spatial filtering based on weighted-orthogonal beamformers in the spherical harmonic domain. IEEE/ACM Transactions on Audio, Speech and Language Processing (TASLP), 24(9), 1507-1519. </dd></dl>

</div>
</div>
<a id="a08d3bc0f9e750716e3fb73c1c3aafe6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08d3bc0f9e750716e3fb73c1c3aafe6e">&#9670;&nbsp;</a></span>generateMinNormMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void generateMinNormMap </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>Cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>Y_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nSources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nGrid_dirs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>logScaleFlag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pmap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates an activity-map based on the sub-space minimum-norm (MinNorm) method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Analysis order </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Cx</td><td>Correlation/covarience matrix; FLAT: (order+1)^2 x (order+1)^2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Y_grid</td><td>Steering vectors for each grid direcionts; FLAT: (order+1)^2 x nGrid_dirs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nSources</td><td>Number of sources present in sound scene </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nGrid_dirs</td><td>Number of grid directions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">logScaleFlag</td><td>'1' log(pmap), '0' pmap. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pmap</td><td>Resulting MinNorm pseudo-spectrum; nGrid_dirs x 1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c430bacc593f41dbc7b0b1ba6c912cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c430bacc593f41dbc7b0b1ba6c912cd">&#9670;&nbsp;</a></span>generateMUSICmap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void generateMUSICmap </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>Cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>Y_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nSources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nGrid_dirs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>logScaleFlag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pmap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates an activity-map based on the sub-space multiple-signal classification (MUSIC) method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Analysis order </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Cx</td><td>Correlation/covarience matrix; FLAT: (order+1)^2 x (order+1)^2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Y_grid</td><td>Steering vectors for each grid direcionts; FLAT: (order+1)^2 x nGrid_dirs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nSources</td><td>Number of sources present in sound scene </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nGrid_dirs</td><td>Number of grid directions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">logScaleFlag</td><td>'1' log(pmap), '0' pmap. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pmap</td><td>Resulting MUSIC pseudo-spectrum; nGrid_dirs x 1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a623080053b63c3a918485dcba3e084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a623080053b63c3a918485dcba3e084">&#9670;&nbsp;</a></span>generateMVDRmap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void generateMVDRmap </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>Cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>Y_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nGrid_dirs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>regPar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>w_MVDR</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a powermap based on the energy of adaptive minimum variance distortion-less response (MVDR) beamformers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Analysis order </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Cx</td><td>Correlation/covarience matrix; FLAT: (order+1)^2 x (order+1)^2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Y_grid</td><td>Steering vectors for each grid direcionts; FLAT: (order+1)^2 x nGrid_dirs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nGrid_dirs</td><td>Number of grid directions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">regPar</td><td>Regularisation parameter, for diagonal loading of Cx </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pmap</td><td>Resulting MVDR powermap; nGrid_dirs x 1 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">w_MVDR</td><td>(Optional) weights will be copied to this, unless it's NULL; FLAT: nSH x nGrid_dirs || NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac6b1194ee375caef234c1302fddce718"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6b1194ee375caef234c1302fddce718">&#9670;&nbsp;</a></span>generatePWDmap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void generatePWDmap </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>Cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>Y_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nGrid_dirs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pmap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a powermap based on the energy of plane-wave decomposition (PWD)/ hyper-cardioid beamformers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Analysis order </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Cx</td><td>Correlation/covarience matrix; FLAT: (order+1)^2 x (order+1)^2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Y_grid</td><td>Steering vectors for each grid direcionts; FLAT: (order+1)^2 x nGrid_dirs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nGrid_dirs</td><td>Number of grid directions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pmap</td><td>Resulting PWD powermap; nGrid_dirs x 1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4f83c48c3d7c7f20726512e0495cf4b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f83c48c3d7c7f20726512e0495cf4b9">&#9670;&nbsp;</a></span>getSHcomplex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getSHcomplex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>dirs_rad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nDirs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes COMPLEX spherical harmonics [1] for each direction on the sphere. </p>
<p>The real spherical harmonics are computed WITH the 1/sqrt(4*pi) term. i.e. max(omni) = 1/sqrt(4*pi) + i0. This function employs 'unnorm_legendreP' and double precision.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Order of spherical harmonic expansion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dirs_rad</td><td>Directions on the sphere [azi, INCLINATION] convention, in RADIANS; FLAT: nDirs x 2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nDirs</td><td>Number of directions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Y</td><td>The SH weights [WITH the 1/sqrt(4*pi)]; FLAT: (order+1)^2 x nDirs</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>[1] Rafaely, B. (2015). Fundamentals of spherical array processing (Vol. 8). Berlin: Springer. </dd></dl>

</div>
</div>
<a id="adab8bc47f1068e8edd58e5d5c93a3fa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adab8bc47f1068e8edd58e5d5c93a3fa4">&#9670;&nbsp;</a></span>getSHreal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getSHreal </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>dirs_rad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nDirs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes REAL spherical harmonics [1] for each direction on the sphere. </p>
<p>The real spherical harmonics are computed WITH the 1/sqrt(4*pi) term. i.e. max(omni) = 1/sqrt(4*pi). Compared to 'getSHreal_recur', this function employs 'unnorm_legendreP' and double precision, which is slower but more precise.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Order of spherical harmonic expansion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dirs_rad</td><td>Directions on the sphere [azi, INCLINATION] convention, in RADIANS; FLAT: nDirs x 2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nDirs</td><td>Number of directions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Y</td><td>The SH weights [WITH the 1/sqrt(4*pi)]; FLAT: (order+1)^2 x nDirs</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>[1] Rafaely, B. (2015). Fundamentals of spherical array processing (Vol. 8). Berlin: Springer. </dd></dl>

</div>
</div>
<a id="abf4d86ed458c9fcdb13065c7e2f4c436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf4d86ed458c9fcdb13065c7e2f4c436">&#9670;&nbsp;</a></span>getSHreal_recur()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getSHreal_recur </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>dirs_rad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nDirs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes REAL spherical harmonics [1] for each direction on the sphere. </p>
<p>The real spherical harmonics are computed WITH the 1/sqrt(4*pi) term. i.e. max(omni) = 1/sqrt(4*pi). Compared to 'getSHreal', this function employs 'unnorm_legendreP_recur' and single precision, which is faster but less precise.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Order of spherical harmonic expansion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dirs_rad</td><td>Directions on the sphere [azi, INCLINATION] convention, in RADIANS; FLAT: nDirs x 2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nDirs</td><td>Number of directions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Y</td><td>The SH weights [WITH the 1/sqrt(4*pi)]; FLAT: (order+1)^2 x nDirs</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>[1] Rafaely, B. (2015). Fundamentals of spherical array processing (Vol. 8). Berlin: Springer. </dd></dl>

</div>
</div>
<a id="abb0681d04a190b7e1fe3d362f301f63e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb0681d04a190b7e1fe3d362f301f63e">&#9670;&nbsp;</a></span>getSHrotMtxReal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getSHrotMtxReal </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>R</em>[3][3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>RotMtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a real-valued spherical harmonic rotation matrix [1] (assumes ACN channel ordering convention). </p>
<p>Note that the normalisation convention does not matter, as e.g. only dipoles are used to rotated dipoles, quadrapoles to rotate quadrapoles etc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">R</td><td>zyx rotation matrix; 3 x 3 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">L</td><td>Order of spherical harmonic expansion </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RotMtx</td><td>SH domain rotation matrix; FLAT: (L+1)^2 x (L+1)^2</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>[1] Ivanic, J., Ruedenberg, K. (1998). Rotation Matrices for Real Spherical Harmonics. Direct Determination by Recursion Page: Additions and Corrections. Journal of Physical Chemistry A, 102(45), 9099?9100. </dd></dl>

</div>
</div>
<a id="ac5212dd2d7d1c3e5428e0f58161fd618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5212dd2d7d1c3e5428e0f58161fd618">&#9670;&nbsp;</a></span>hankel_Hn1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hankel_Hn1 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double_complex *&#160;</td>
          <td class="paramname"><em>Hn1_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double_complex *&#160;</td>
          <td class="paramname"><em>dHn1_n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the (cylindrical) Hankel function of the first kind: Hn1. </p>
<p>Computes the Hankel values and their derivatives up to order N for all values in vector z</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>Function order (highest is ~30 given numerical precision) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z</td><td>Input values; nZ x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nZ</td><td>Number of input values </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Hn1_n</td><td>Hankel values (set as NULL if not required); FLAT: nZ x (N+1) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dHn1_n</td><td>Hankel derivative values (set as NULL if not required); FLAT: nZ x (N+1) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0cd43009e3663f71077e327ef8b1c3f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cd43009e3663f71077e327ef8b1c3f5">&#9670;&nbsp;</a></span>hankel_hn1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hankel_hn1 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>maxN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double_complex *&#160;</td>
          <td class="paramname"><em>h_n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double_complex *&#160;</td>
          <td class="paramname"><em>dh_n1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the spherical Hankel function of the first kind: hn1. </p>
<p>Computes the Hankel values and their derivatives up to order N for all values in vector z</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>Function order (highest is ~30 given numerical precision) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z</td><td>Input values; nZ x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nZ</td><td>Number of input values </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">maxN</td><td>(&amp;) maximum function order that could be computed &lt;=N </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">h_n1</td><td>Hankel values (set as NULL if not required); FLAT: nZ x (N+1) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dh_n1</td><td>Hankel derivative values (set as NULL if not required); FLAT: nZ x (N+1) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8767d46052f8be003ab60001d161fad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8767d46052f8be003ab60001d161fad3">&#9670;&nbsp;</a></span>hankel_Hn2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hankel_Hn2 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double_complex *&#160;</td>
          <td class="paramname"><em>Hn2_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double_complex *&#160;</td>
          <td class="paramname"><em>dHn2_n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the (cylindrical) Hankel function of the second kind: Hn2. </p>
<p>Computes the Hankel values and their derivatives up to order N for all values in vector z</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>Function order (highest is ~30 given numerical precision) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z</td><td>Input values; nZ x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nZ</td><td>Number of input values </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Hn2_n</td><td>Hankel values (set as NULL if not required); FLAT: nZ x (N+1) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dHn2_n</td><td>Hankel derivative values (set as NULL if not required); FLAT: nZ x (N+1) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a594732d5b9ef92efc01ac73b8e73bfac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a594732d5b9ef92efc01ac73b8e73bfac">&#9670;&nbsp;</a></span>hankel_hn2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hankel_hn2 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>maxN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double_complex *&#160;</td>
          <td class="paramname"><em>h_n2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double_complex *&#160;</td>
          <td class="paramname"><em>dh_n2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the spherical Hankel function of the second kind: hn2. </p>
<p>Computes the Hankel values and their derivatives up to order N for all values in vector z</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>Function order (highest is ~30 given numerical precision) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z</td><td>Input values; nZ x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nZ</td><td>Number of input values </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">maxN</td><td>(&amp;) maximum function order that could be computed &lt;=N </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">h_n2</td><td>Hankel values (set as NULL if not required); FLAT: nZ x (N+1) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dh_n2</td><td>Hankel derivative values (set as NULL if not required); FLAT: nZ x (N+1) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae1bf4d927842a9c97771801f2483b32d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1bf4d927842a9c97771801f2483b32d">&#9670;&nbsp;</a></span>real2complexSHMtx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void real2complexSHMtx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>T_r2c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a real to complex spherical harmonic transform matrix. </p>
<p>Computes the unitary transformation matrix T_r2c the expresses the complex spherical harmonics with respect to the real ones, so that y_N = T_r2c * r_N, where r_N and y_N are the real and complex SH vectors, respectively.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Order of spherical harmonic expansion </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">T_c2r</td><td>Transformation matrix for real-&gt;complex; FLAT: (order+1)^2 x (order+1)^2 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a266a06c6c96240add2d3ab171d89925d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a266a06c6c96240add2d3ab171d89925d">&#9670;&nbsp;</a></span>rotateAxisCoeffsComplex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rotateAxisCoeffsComplex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>c_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>theta_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>phi_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>c_nm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates spherical coefficients for a rotated axisymmetric pattern (COMPLEX) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Order of spherical harmonic expansion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c_n</td><td>Coefficients describing a rotationally symmetric pattern order N, expressed as a sum of spherical harmonics of degree m=0; (N+1) x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">theta_0</td><td>POLAR rotation for the pattern, in RADIANS </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">phi_0</td><td>Azimuthal rotation for the pattern, in RADIANS </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">c_nm</td><td>Coefficients of rotated pattern expressed as a sum of SHs; (N+1)^2 x 1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a824b11467b1f54b0725264b256f6a193"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a824b11467b1f54b0725264b256f6a193">&#9670;&nbsp;</a></span>rotateAxisCoeffsReal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rotateAxisCoeffsReal </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>c_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>theta_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>phi_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>c_nm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates spherical coefficients for a rotated axisymmetric pattern (REAL) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Order of spherical harmonic expansion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c_n</td><td>Coefficients describing a rotationally symmetric pattern order N, expressed as a sum of spherical harmonics of degree m=0; (N+1) x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">theta_0</td><td>POLAR rotation for the pattern, in RADIANS </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">phi_0</td><td>Azimuthal rotation for the pattern, in RADIANS </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">c_nm</td><td>Coefficients of rotated pattern expressed as a sum of SHs; (N+1)^2 x 1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa5203b16cf67ef27b422078d20618863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5203b16cf67ef27b422078d20618863">&#9670;&nbsp;</a></span>simulateCylArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void simulateCylArray </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>kr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nBands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>sensor_dirs_rad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_sensors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>src_dirs_deg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_srcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="saf__sh_8h.html#a89fc3daef304221a6826fd6916396e5f">ARRAY_CONSTRUCTION_TYPES</a>&#160;</td>
          <td class="paramname"><em>arrayType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>H_array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simulates a cylindrical microphone array, returning the transfer functions for each (plane wave) source direction on the surface of the cylinder. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Max order (highest is ~30 given numerical precision) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kr</td><td>wavenumber*radius; nBands x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nBands</td><td>Number of frequency bands/bins </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sensor_dirs_rad</td><td>Spherical coords of the sensors in RADIANS, [azi ELEV]; FLAT: N_sensors x 2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_sensors</td><td>Number of sensors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src_dirs_deg</td><td>Spherical coords of the plane waves in DEGREES, [azi ELEV]; FLAT: N_srcs x 2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_srcs</td><td>Number sources (DoAs of plane waves) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arrayType</td><td>See 'ARRAY_CONSTRUCTION_TYPES' enum </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">H_array</td><td>Simulated array response for each plane wave; FLAT: nBands x N_sensors x N_srcs </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab4fe5085d4cc6223772f6e49ef74f355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4fe5085d4cc6223772f6e49ef74f355">&#9670;&nbsp;</a></span>simulateSphArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void simulateSphArray </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>kr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>kR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nBands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>sensor_dirs_rad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_sensors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>src_dirs_deg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_srcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="saf__sh_8h.html#a89fc3daef304221a6826fd6916396e5f">ARRAY_CONSTRUCTION_TYPES</a>&#160;</td>
          <td class="paramname"><em>arrayType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dirCoeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>H_array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simulates a spherical microphone array, returning the transfer functions for each (plane wave) source direction on the surface of the sphere. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Max order (highest is ~30 given numerical precision) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kr</td><td>wavenumber*array_radius; nBands x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kR</td><td>wavenumber*scatterer_radius, set to NULL if not needed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nBands</td><td>Number of frequency bands/bins </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sensor_dirs_rad</td><td>Spherical coords of the sensors in RADIANS, [azi ELEV]; FLAT: N_sensors x 2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_sensors</td><td>Number of sensors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src_dirs_deg</td><td>Spherical coords of the plane waves in DEGREES, [azi ELEV]; FLAT: N_srcs x 2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_srcs</td><td>Number sources (DoAs of plane waves) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arrayType</td><td>See 'ARRAY_CONSTRUCTION_TYPES' enum </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dirCoeff</td><td>Only for directional (open) arrays, 1: omni, 0.5: card, 0:dipole </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">H_array</td><td>Simulated array response for each plane wave; FLAT: nBands x N_sensors x N_srcs </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a898eab67c2144d794201bbc80c2c6aa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a898eab67c2144d794201bbc80c2c6aa2">&#9670;&nbsp;</a></span>sphArrayAliasLim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float sphArrayAliasLim </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxN</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a simple estimate of the spatial aliasing limit (the kR = maxN rule) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>Array radius, meters </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>Speed of sound, m/s </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxN</td><td>Order </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>spatial aliasing limit estimate </dd></dl>

</div>
</div>
<a id="a9774e448be3d0caf15ce45077d0d5ebe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9774e448be3d0caf15ce45077d0d5ebe">&#9670;&nbsp;</a></span>sphArrayNoiseThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sphArrayNoiseThreshold </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Nsensors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="saf__sh_8h.html#a89fc3daef304221a6826fd6916396e5f">ARRAY_CONSTRUCTION_TYPES</a>&#160;</td>
          <td class="paramname"><em>arrayType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dirCoeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>maxG_db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>f_lim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the frequncies (per order), at which the noise of a SHT of a SMA exceeds a specified maximum level. </p>
<p>Computes the frequencies that the noise in the output channels of a spherical microphone array (SMA), after performing the spherical harmonic transform (SHT) and equalisation of the output signals, reaches a certain user-defined threshold maxG_db. The frequencies are computed only at the lower range of each order, where its response decays rapidly, ignoring for example the nulls of an open array at the higher frequencies. The estimation of the limits are based on a linear approximation of the log-log response found e.g. in [1]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">maxN</td><td>Maximum order of the array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Nsensors</td><td>Number of sensors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>Mic radius, meters </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>Speed of sound, m/s </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arrayType</td><td>See 'ARRAY_CONSTRUCTION_TYPES' enum </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dirCoeff</td><td>Only for directional (open) arrays, 1: omni, 0.5: card, 0:dipole </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxG_db</td><td>Max allowed amplification for the noise level, maxG_db = 20*log10(maxG) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">f_lim</td><td>Noise limit estimate; (maxN+1) x 1</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>[1] Sector-based Parametric Sound Field Reproduction in the Spherical Harmonic Domain A Politis, J Vilkamo, V Pulkki. 2015. IEEE Journal of Selected Topics in Signal Processing 9 (5), 852 - 866 </dd></dl>

</div>
</div>
<a id="ac3c0a54aacdd607e5d305db0e362cfce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3c0a54aacdd607e5d305db0e362cfce">&#9670;&nbsp;</a></span>sphDiffCohMtxTheory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sphDiffCohMtxTheory </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>sensor_dirs_rad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_sensors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="saf__sh_8h.html#a89fc3daef304221a6826fd6916396e5f">ARRAY_CONSTRUCTION_TYPES</a>&#160;</td>
          <td class="paramname"><em>arrayType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dirCoeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>kr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>kR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nBands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>M_diffcoh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the theoretical diffuse coherence matrix for a spherical array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Max order (highest is ~30 given numerical precision) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sensor_dirs_rad</td><td>Spherical coords of the sensors in RADIANS, [azi ELEV]; FLAT: N_sensors x 2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_sensors</td><td>Number of sensors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arrayType</td><td>See 'ARRAY_CONSTRUCTION_TYPES' enum </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dirCoeff</td><td>Only for directional (open) arrays, 1: omni, 0.5: card, 0:dipole </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kr</td><td>wavenumber*sensor_radius; nBands x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kR</td><td>wavenumber*scatterer_radius, set to NULL if not applicable; nBands x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nBands</td><td>Number of frequency bands/bins </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">M_diffcoh</td><td>Theoretical diffuse coherence matrix per frequency; FLAT: N_sensors x N_sensors x nBands </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6c331fd73b56845ab0ecbf4b0d5fc640"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c331fd73b56845ab0ecbf4b0d5fc640">&#9670;&nbsp;</a></span>sphModalCoeffs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sphModalCoeffs </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>kr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nBands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="saf__sh_8h.html#a89fc3daef304221a6826fd6916396e5f">ARRAY_CONSTRUCTION_TYPES</a>&#160;</td>
          <td class="paramname"><em>arrayType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dirCoeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double_complex *&#160;</td>
          <td class="paramname"><em>b_N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the modal coefficients for open/rigid spherical arrays. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Max order (highest is ~30 given numerical precision) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kr</td><td>wavenumber*radius; nBands x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nBands</td><td>Number of frequency bands/bins </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arrayType</td><td>See 'ARRAY_CONSTRUCTION_TYPES' enum </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dirCoeff</td><td>Only for directional (open) arrays, 1: omni, 0.5: card, 0:dipole </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">b_N</td><td>Modal coefficients per kr and 0:order; FLAT: nBands x (order+1) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aedc488e33c0239baebed8cd7aeabd8a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedc488e33c0239baebed8cd7aeabd8a7">&#9670;&nbsp;</a></span>sphScattererDirModalCoeffs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sphScattererDirModalCoeffs </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>kr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>kR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nBands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dirCoeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double_complex *&#160;</td>
          <td class="paramname"><em>b_N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the modal coefficients for a rigid spherical scatterer with directional sensors. </p>
<p>Assumes all sensors are placed the same distance from the scatterer, w.r.t. the origin</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Max order (highest is ~30 given numerical precision) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kr</td><td>wavenumber*array_radius; nBands x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kR</td><td>wavenumber*scatterer_radius; nBands x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nBands</td><td>Number of frequency bands/bins </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dirCoeff</td><td>Directivity coefficient, 1: omni, 0.5: card, 0:dipole </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">b_N</td><td>Modal coefficients per kr and 0:order; FLAT: nBands x (order+1) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc74c9714841c3f48974fe10e6485eea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc74c9714841c3f48974fe10e6485eea">&#9670;&nbsp;</a></span>sphScattererModalCoeffs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sphScattererModalCoeffs </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>kr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>kR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nBands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double_complex *&#160;</td>
          <td class="paramname"><em>b_N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the modal coefficients for a rigid spherical scatterer with omni-directional sensors. </p>
<p>Assumes all sensors are placed the same distance from the scatterer, w.r.t. the origin</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Max order (highest is ~30 given numerical precision) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kr</td><td>wavenumber*array_radius; nBands x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kR</td><td>wavenumber*scatterer_radius; nBands x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nBands</td><td>Number of frequency bands/bins </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">b_N</td><td>Modal coefficients per kr and 0:order; FLAT: nBands x (order+1) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee36d05adf2e71f9e9559448622f0ca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee36d05adf2e71f9e9559448622f0ca0">&#9670;&nbsp;</a></span>unitCart2Sph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void unitCart2Sph </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>xyz</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>AziElev_rad</em>[2]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts cartesian coordinates of unit length to spherical coordinates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xyz</td><td>Unit cartesian coords, xyz </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">AziElev_rad</td><td>Azimuth and elevation in radians </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8dfd8725c78271229ee433e7d76899d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dfd8725c78271229ee433e7d76899d0">&#9670;&nbsp;</a></span>unitCart2Sph_aziElev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void unitCart2Sph_aziElev </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>xyz</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>azi_rad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>elev_rad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts cartesian coordinates of unit length to spherical coordinates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xyz</td><td>Unit cartesian coords, xyz </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">azi_rad</td><td>(&amp;) azimuth in radians </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">elev_rad</td><td>(&amp;) elevation in radians </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a118e9de5ec5a4289f9bc935d89594202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a118e9de5ec5a4289f9bc935d89594202">&#9670;&nbsp;</a></span>unitSph2Cart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void unitSph2Cart </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>azi_rad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>elev_rad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>xyz</em>[3]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts spherical coordinates to cartesian coordinates of unit length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">azi_rad</td><td>Azimuth in radians </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elev_rad</td><td>Elevation in radians </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">xyz</td><td>Unit cartesian coords, xyz; 3 x 1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1ff15ddf9e257b1f185421568ef349dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ff15ddf9e257b1f185421568ef349dd">&#9670;&nbsp;</a></span>unnorm_legendreP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void unnorm_legendreP </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lenX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates unnormalised legendre polynomials up to order N, for all values in vector x [1]. </p>
<dl class="section note"><dt>Note</dt><dd>This INCLUDES the Condon-Shortley phase term. It is functionally identical to Matlab's legendre function (with default settings ['unnorm']).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Order of legendre polynomial </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Vector of input values; lenX x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lenX</td><td>Number of input values </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">y</td><td>Resulting unnormalised legendre values for each x value; FLAT: (n+1) x lenX</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>[1] M, Abramowitz., I.A. Stegun. (1965). "Handbook of Mathematical
         Functions: Chapter 8", Dover Publications. </dd></dl>

</div>
</div>
<a id="a3851842c7f6c520c3f645f0ae686443c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3851842c7f6c520c3f645f0ae686443c">&#9670;&nbsp;</a></span>unnorm_legendreP_recur()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void unnorm_legendreP_recur </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lenX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>Pnm_minus1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>Pnm_minus2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>Pnm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates unnormalised legendre polynomials up to order N, for all values in vector x. </p>
<p>It uses a recursive approach, which makes it more suitable for computing the legendre values in a real-time loop.</p>
<dl class="section note"><dt>Note</dt><dd>This does NOT INCLUDE the Condon-Shortley phase term.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Order of legendre polynomial </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Vector of input values; lenX x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lenX</td><td>Number of input values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Pnm_minus1</td><td>Previous Pnm, (not used for n=1); FLAT: (n+1) x lenX </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Pnm_minus2</td><td>Previous previous Pnm, (not used for n=0); FLAT: (n+1) x lenX </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Pnm</td><td>Resulting unnormalised legendre values for each x value; FLAT: (n+1) x lenX </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac71d1d0c99dbe0cc27bd25790e04d779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac71d1d0c99dbe0cc27bd25790e04d779">&#9670;&nbsp;</a></span>yawPitchRoll2Rzyx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void yawPitchRoll2Rzyx </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>yaw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>pitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>roll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rollPitchYawFLAG</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>R</em>[3][3]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a 3x3 rotation matrix from the Euler angles, using the yaw-pitch-roll (zyx) convention. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">yaw</td><td>Yaw angle in radians </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pitch</td><td>Pitch angle in radians </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">roll</td><td>Roll angle in radians </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rollPitchYawFLAG</td><td>'1' to use Rxyz, i.e. apply roll, pitch and then yaw, '0' Rzyx / y-p-r </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">R</td><td>zyx rotation matrix; 3 x 3 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_644e041c3a6521da7b27eba0e4eb2b95.html">framework</a></li><li class="navelem"><a class="el" href="dir_56553b6b74e7f4a7717200a52c59b140.html">modules</a></li><li class="navelem"><a class="el" href="dir_a3800911dd78ba56a8d7acc21219fcab.html">saf_sh</a></li><li class="navelem"><a class="el" href="saf__sh_8h.html">saf_sh.h</a></li>
    <li class="footer">Generated on Wed Mar 4 2020 13:32:58 for Spatial_Audio_Framework by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>

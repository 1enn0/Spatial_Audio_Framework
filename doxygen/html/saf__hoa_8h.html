<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Spatial_Audio_Framework: /Users/mccorml1/Documents/SourceTree/SPARTA_VSTs_public/SDKs/Spatial_Audio_Framework/framework/modules/saf_hoa/saf_hoa.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Spatial_Audio_Framework
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('saf__hoa_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">saf_hoa.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Public part of the "saf_hoa" module.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="saf__complex_8h_source.html">../saf_utilities/saf_complex.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="saf__error_8h_source.html">../saf_utilities/saf_error.h</a>&quot;</code><br />
</div>
<p><a href="saf__hoa_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aba54133ba006a9eef3d417bb11983fcb"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="saf__hoa_8h.html#a796edc50316c6c13a47e667149148b02">_LOUDSPEAKER_AMBI_DECODER_METHODS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__hoa_8h.html#aba54133ba006a9eef3d417bb11983fcb">LOUDSPEAKER_AMBI_DECODER_METHODS</a></td></tr>
<tr class="memdesc:aba54133ba006a9eef3d417bb11983fcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ambisonic decoding options for loudspeaker playback.  <a href="saf__hoa_8h.html#aba54133ba006a9eef3d417bb11983fcb">More...</a><br /></td></tr>
<tr class="separator:aba54133ba006a9eef3d417bb11983fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35e46e1cae92fe146d3037df17c22e0a"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="saf__hoa_8h.html#ad74dc367c1472fd60b3a66934aa92d41">_BINAURAL_AMBI_DECODER_METHODS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__hoa_8h.html#a35e46e1cae92fe146d3037df17c22e0a">BINAURAL_AMBI_DECODER_METHODS</a></td></tr>
<tr class="memdesc:a35e46e1cae92fe146d3037df17c22e0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ambisonic decoding options for binaural/headphone playback.  <a href="saf__hoa_8h.html#a35e46e1cae92fe146d3037df17c22e0a">More...</a><br /></td></tr>
<tr class="separator:a35e46e1cae92fe146d3037df17c22e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a796edc50316c6c13a47e667149148b02"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__hoa_8h.html#a796edc50316c6c13a47e667149148b02">_LOUDSPEAKER_AMBI_DECODER_METHODS</a> { <br />
&#160;&#160;<a class="el" href="saf__hoa_8h.html#a796edc50316c6c13a47e667149148b02aa1dad6c278efa25907a0b64fb2942e26">LOUDSPEAKER_DECODER_DEFAULT</a>, 
<a class="el" href="saf__hoa_8h.html#a796edc50316c6c13a47e667149148b02a743482262e1deb4c4511d2a9cbaddff6">LOUDSPEAKER_DECODER_SAD</a>, 
<a class="el" href="saf__hoa_8h.html#a796edc50316c6c13a47e667149148b02ae1f628a0188a79ae586ae270a0a8b508">LOUDSPEAKER_DECODER_MMD</a>, 
<a class="el" href="saf__hoa_8h.html#a796edc50316c6c13a47e667149148b02aa1e10487b21890502a1c72b34d2b7add">LOUDSPEAKER_DECODER_EPAD</a>, 
<br />
&#160;&#160;<a class="el" href="saf__hoa_8h.html#a796edc50316c6c13a47e667149148b02a30fc2a59a858885b6651fd5a1fd34145">LOUDSPEAKER_DECODER_ALLRAD</a>
<br />
 }</td></tr>
<tr class="memdesc:a796edc50316c6c13a47e667149148b02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ambisonic decoding options for loudspeaker playback.  <a href="saf__hoa_8h.html#a796edc50316c6c13a47e667149148b02">More...</a><br /></td></tr>
<tr class="separator:a796edc50316c6c13a47e667149148b02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad74dc367c1472fd60b3a66934aa92d41"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__hoa_8h.html#ad74dc367c1472fd60b3a66934aa92d41">_BINAURAL_AMBI_DECODER_METHODS</a> { <br />
&#160;&#160;<a class="el" href="saf__hoa_8h.html#ad74dc367c1472fd60b3a66934aa92d41ab9d8239b3e918ada247720015cee827f">BINAURAL_DECODER_DEFAULT</a>, 
<a class="el" href="saf__hoa_8h.html#ad74dc367c1472fd60b3a66934aa92d41a25059f43250b90fb659563953d6e52a4">BINAURAL_DECODER_LS</a>, 
<a class="el" href="saf__hoa_8h.html#ad74dc367c1472fd60b3a66934aa92d41aea7d5ff9e0fec9c3e86274cde48a6436">BINAURAL_DECODER_LSDIFFEQ</a>, 
<a class="el" href="saf__hoa_8h.html#ad74dc367c1472fd60b3a66934aa92d41ab52d181ecdf9d10fcb9c5d761cac8a98">BINAURAL_DECODER_SPR</a>, 
<br />
&#160;&#160;<a class="el" href="saf__hoa_8h.html#ad74dc367c1472fd60b3a66934aa92d41ad06de101e3b304af994c611b744df457">BINAURAL_DECODER_TA</a>, 
<a class="el" href="saf__hoa_8h.html#ad74dc367c1472fd60b3a66934aa92d41a02f30e94818bd69708ce020110589ce4">BINAURAL_DECODER_MAGLS</a>
<br />
 }</td></tr>
<tr class="memdesc:ad74dc367c1472fd60b3a66934aa92d41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ambisonic decoding options for binaural/headphone playback.  <a href="saf__hoa_8h.html#ad74dc367c1472fd60b3a66934aa92d41">More...</a><br /></td></tr>
<tr class="separator:ad74dc367c1472fd60b3a66934aa92d41"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac2804e1b897727e3ed1cd0d6dc74d179"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__hoa_8h.html#ac2804e1b897727e3ed1cd0d6dc74d179">getRSH</a> (int order, float *dirs_deg, int nDirs, float *Y)</td></tr>
<tr class="memdesc:ac2804e1b897727e3ed1cd0d6dc74d179"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes REAL spherical harmonics [1] for multiple directions on the sphere.  <a href="saf__hoa_8h.html#ac2804e1b897727e3ed1cd0d6dc74d179">More...</a><br /></td></tr>
<tr class="separator:ac2804e1b897727e3ed1cd0d6dc74d179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af095b87aecb2c38ce5014669c70d4f6f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__hoa_8h.html#af095b87aecb2c38ce5014669c70d4f6f">getRSH_recur</a> (int order, float *dirs_deg, int nDirs, float *Y)</td></tr>
<tr class="memdesc:af095b87aecb2c38ce5014669c70d4f6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes REAL spherical harmonics [1] for multiple directions on the sphere.  <a href="saf__hoa_8h.html#af095b87aecb2c38ce5014669c70d4f6f">More...</a><br /></td></tr>
<tr class="separator:af095b87aecb2c38ce5014669c70d4f6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2dc357da0a7df362e1d53a91936955c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__hoa_8h.html#af2dc357da0a7df362e1d53a91936955c">getMaxREweights</a> (int order, int diagMtxFlag, float *a_n)</td></tr>
<tr class="memdesc:af2dc357da0a7df362e1d53a91936955c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the weights required to manipulate a hyper-cardioid beam-pattern, such that it has maximum energy in the given look-direction.  <a href="saf__hoa_8h.html#af2dc357da0a7df362e1d53a91936955c">More...</a><br /></td></tr>
<tr class="separator:af2dc357da0a7df362e1d53a91936955c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdbcb0988d23373cf5062d2fa2a283da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__hoa_8h.html#afdbcb0988d23373cf5062d2fa2a283da">getLoudspeakerAmbiDecoderMtx</a> (float *ls_dirs_deg, int nLS, <a class="el" href="saf__hoa_8h.html#aba54133ba006a9eef3d417bb11983fcb">LOUDSPEAKER_AMBI_DECODER_METHODS</a> method, int order, int enableMaxrE, float *decMtx)</td></tr>
<tr class="memdesc:afdbcb0988d23373cf5062d2fa2a283da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an ambisonic decoding matrix of a specific order, for a specific loudspeaker layout.  <a href="saf__hoa_8h.html#afdbcb0988d23373cf5062d2fa2a283da">More...</a><br /></td></tr>
<tr class="separator:afdbcb0988d23373cf5062d2fa2a283da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a291c22e193e90d410b9ec3c5f3a01a11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__hoa_8h.html#a291c22e193e90d410b9ec3c5f3a01a11">getBinauralAmbiDecoderMtx</a> (float_complex *hrtfs, float *hrtf_dirs_deg, int N_dirs, int N_bands, <a class="el" href="saf__hoa_8h.html#a35e46e1cae92fe146d3037df17c22e0a">BINAURAL_AMBI_DECODER_METHODS</a> method, int order, float *freqVector, float *itd_s, float *weights, int enableDiffCM, int enableMaxrE, float_complex *decMtx)</td></tr>
<tr class="memdesc:a291c22e193e90d410b9ec3c5f3a01a11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes binaural ambisonic decoding matrices (one per frequency) at a specific order, for a given HRTF set.  <a href="saf__hoa_8h.html#a291c22e193e90d410b9ec3c5f3a01a11">More...</a><br /></td></tr>
<tr class="separator:a291c22e193e90d410b9ec3c5f3a01a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa84a59d7917e33747541580167c02e76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__hoa_8h.html#aa84a59d7917e33747541580167c02e76">getBinauralAmbiDecoderFilters</a> (float_complex *hrtfs, float *hrtf_dirs_deg, int N_dirs, int fftSize, float fs, <a class="el" href="saf__hoa_8h.html#a35e46e1cae92fe146d3037df17c22e0a">BINAURAL_AMBI_DECODER_METHODS</a> method, int order, float *itd_s, float *weights, int enableDiffCM, int enableMaxrE, float *decFilters)</td></tr>
<tr class="memdesc:aa84a59d7917e33747541580167c02e76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes ambisonic decoding filters for a given HRTF set.  <a href="saf__hoa_8h.html#aa84a59d7917e33747541580167c02e76">More...</a><br /></td></tr>
<tr class="separator:aa84a59d7917e33747541580167c02e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cc8fcc9d1b9981fbc9e6097c97495d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__hoa_8h.html#a1cc8fcc9d1b9981fbc9e6097c97495d4">applyDiffCovMatching</a> (float_complex *hrtfs, float *hrtf_dirs_deg, int N_dirs, int N_bands, int order, float *weights, float_complex *decMtx)</td></tr>
<tr class="memdesc:a1cc8fcc9d1b9981fbc9e6097c97495d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Imposes a diffuse-field covariance constraint on a given binaural decoding matrix [1].  <a href="saf__hoa_8h.html#a1cc8fcc9d1b9981fbc9e6097c97495d4">More...</a><br /></td></tr>
<tr class="separator:a1cc8fcc9d1b9981fbc9e6097c97495d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Public part of the "saf_hoa" module. </p>
<p>A collection of Ambisonics related functions. Many of which are derived from the Matlab library by Archontis Politis [1].</p>
<dl class="section see"><dt>See also</dt><dd>[1] <a href="https://github.com/polarch/Higher-Order-Ambisonics">https://github.com/polarch/Higher-Order-Ambisonics</a></dd></dl>
<dl class="section author"><dt>Author</dt><dd>Leo McCormack </dd></dl>
<dl class="section date"><dt>Date</dt><dd>19.03.2018 </dd></dl>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a35e46e1cae92fe146d3037df17c22e0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35e46e1cae92fe146d3037df17c22e0a">&#9670;&nbsp;</a></span>BINAURAL_AMBI_DECODER_METHODS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="saf__hoa_8h.html#ad74dc367c1472fd60b3a66934aa92d41">_BINAURAL_AMBI_DECODER_METHODS</a> <a class="el" href="saf__hoa_8h.html#a35e46e1cae92fe146d3037df17c22e0a">BINAURAL_AMBI_DECODER_METHODS</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ambisonic decoding options for binaural/headphone playback. </p>
<dl class="section note"><dt>Note</dt><dd>A more detailed description of each method may be found in "saf_hoa_internal.h".</dd></dl>
<dl class="section see"><dt>See also</dt><dd>[1] Z. Ben-Hur, F. Brinkmann, J. Sheaffer, S. Weinzierl, and B. Rafaely, "Spectral equalization in binaural signals represented by order-
         truncated spherical harmonics," The Journal of the Acoustical Society of America, vol. 141, no. 6, pp. 4087–4096, 2017. </dd>
<dd>
[2] B. Bernschutz, A. V. Giner, C. Pörschmann, and J. Arend, “Binaural reproduction of plane waves with reduced modal order,” Acta Acustica united with Acustica, vol. 100, no. 5, pp. 972–983, 2014. </dd>
<dd>
[3] Zaunschirm M, Schörkhuber C, Höldrich R. Binaural rendering of Ambisonic signals by head-related impulse response time alignment and a diffuseness constraint. The Journal of the Acoustical Society of America. 2018 Jun 19;143(6):3616-27 </dd>
<dd>
[4] Schörkhuber C, Zaunschirm M, Höldrich R. Binaural Rendering of Ambisonic Signals via Magnitude Least Squares. InProceedings of the DAGA 2018 (Vol. 44, pp. 339-342). </dd></dl>

</div>
</div>
<a id="aba54133ba006a9eef3d417bb11983fcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba54133ba006a9eef3d417bb11983fcb">&#9670;&nbsp;</a></span>LOUDSPEAKER_AMBI_DECODER_METHODS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="saf__hoa_8h.html#a796edc50316c6c13a47e667149148b02">_LOUDSPEAKER_AMBI_DECODER_METHODS</a> <a class="el" href="saf__hoa_8h.html#aba54133ba006a9eef3d417bb11983fcb">LOUDSPEAKER_AMBI_DECODER_METHODS</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ambisonic decoding options for loudspeaker playback. </p>
<p>Note that all of these decoding options revert to "SAD" if the loudspeakers are uniformly distributed on the sphere. The benefits afforded by MMD, AllRAD, etc. relate to their improved performance when using irregular loudspeaker arrangements.</p>
<dl class="section see"><dt>See also</dt><dd>[1] Zotter F, Pomberger H, Noisternig M. Energy- preserving ambisonic decoding. Acta Acustica united with Acustica. 2012 Jan 1; 98(1):37-47. </dd>
<dd>
[2] Zotter F, Frank M. All-round ambisonic panning and decoding. Journal of the audio engineering society. 2012 Nov 26; 60(10):807-20. </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ad74dc367c1472fd60b3a66934aa92d41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad74dc367c1472fd60b3a66934aa92d41">&#9670;&nbsp;</a></span>_BINAURAL_AMBI_DECODER_METHODS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="saf__hoa_8h.html#ad74dc367c1472fd60b3a66934aa92d41">_BINAURAL_AMBI_DECODER_METHODS</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ambisonic decoding options for binaural/headphone playback. </p>
<dl class="section note"><dt>Note</dt><dd>A more detailed description of each method may be found in "saf_hoa_internal.h".</dd></dl>
<dl class="section see"><dt>See also</dt><dd>[1] Z. Ben-Hur, F. Brinkmann, J. Sheaffer, S. Weinzierl, and B. Rafaely, "Spectral equalization in binaural signals represented by order-
         truncated spherical harmonics," The Journal of the Acoustical Society of America, vol. 141, no. 6, pp. 4087–4096, 2017. </dd>
<dd>
[2] B. Bernschutz, A. V. Giner, C. Pörschmann, and J. Arend, “Binaural reproduction of plane waves with reduced modal order,” Acta Acustica united with Acustica, vol. 100, no. 5, pp. 972–983, 2014. </dd>
<dd>
[3] Zaunschirm M, Schörkhuber C, Höldrich R. Binaural rendering of Ambisonic signals by head-related impulse response time alignment and a diffuseness constraint. The Journal of the Acoustical Society of America. 2018 Jun 19;143(6):3616-27 </dd>
<dd>
[4] Schörkhuber C, Zaunschirm M, Höldrich R. Binaural Rendering of Ambisonic Signals via Magnitude Least Squares. InProceedings of the DAGA 2018 (Vol. 44, pp. 339-342). </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad74dc367c1472fd60b3a66934aa92d41ab9d8239b3e918ada247720015cee827f"></a>BINAURAL_DECODER_DEFAULT&#160;</td><td class="fielddoc"><p>The default decoder is "BINAURAL_DECODER_LS". </p>
</td></tr>
<tr><td class="fieldname"><a id="ad74dc367c1472fd60b3a66934aa92d41a25059f43250b90fb659563953d6e52a4"></a>BINAURAL_DECODER_LS&#160;</td><td class="fielddoc"><p>Least-squares (LS) decoder. </p>
<p>The simplest binaural decoder. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad74dc367c1472fd60b3a66934aa92d41aea7d5ff9e0fec9c3e86274cde48a6436"></a>BINAURAL_DECODER_LSDIFFEQ&#160;</td><td class="fielddoc"><p>Least-squares (LS) decoder with diffuse-field spectral equalisation [1]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad74dc367c1472fd60b3a66934aa92d41ab52d181ecdf9d10fcb9c5d761cac8a98"></a>BINAURAL_DECODER_SPR&#160;</td><td class="fielddoc"><p>Spatial resampling decoder (on the same lines as the virtual loudspeaker approach) [2]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad74dc367c1472fd60b3a66934aa92d41ad06de101e3b304af994c611b744df457"></a>BINAURAL_DECODER_TA&#160;</td><td class="fielddoc"><p>Time-alignment decoder [3]. </p>
<p>Relies on discarding the phase information of the HRTFs, past the frequency at which humans are less sensitive to inter-aural time differences. Therefore, the least-squares fitting priorites matching the interaural level differences (ILDs), rather than the interaural time differences (ITDs). </p>
</td></tr>
<tr><td class="fieldname"><a id="ad74dc367c1472fd60b3a66934aa92d41a02f30e94818bd69708ce020110589ce4"></a>BINAURAL_DECODER_MAGLS&#160;</td><td class="fielddoc"><p>Magnitude least-squares decoder [4]. </p>
<p>On similar lines to the time- alignment decoder, but differing in its execution. </p>
</td></tr>
</table>

</div>
</div>
<a id="a796edc50316c6c13a47e667149148b02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a796edc50316c6c13a47e667149148b02">&#9670;&nbsp;</a></span>_LOUDSPEAKER_AMBI_DECODER_METHODS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="saf__hoa_8h.html#a796edc50316c6c13a47e667149148b02">_LOUDSPEAKER_AMBI_DECODER_METHODS</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ambisonic decoding options for loudspeaker playback. </p>
<p>Note that all of these decoding options revert to "SAD" if the loudspeakers are uniformly distributed on the sphere. The benefits afforded by MMD, AllRAD, etc. relate to their improved performance when using irregular loudspeaker arrangements.</p>
<dl class="section see"><dt>See also</dt><dd>[1] Zotter F, Pomberger H, Noisternig M. Energy- preserving ambisonic decoding. Acta Acustica united with Acustica. 2012 Jan 1; 98(1):37-47. </dd>
<dd>
[2] Zotter F, Frank M. All-round ambisonic panning and decoding. Journal of the audio engineering society. 2012 Nov 26; 60(10):807-20. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a796edc50316c6c13a47e667149148b02aa1dad6c278efa25907a0b64fb2942e26"></a>LOUDSPEAKER_DECODER_DEFAULT&#160;</td><td class="fielddoc"><p>The default decoder is "LOUDSPEAKER_DECODER_SAD". </p>
</td></tr>
<tr><td class="fieldname"><a id="a796edc50316c6c13a47e667149148b02a743482262e1deb4c4511d2a9cbaddff6"></a>LOUDSPEAKER_DECODER_SAD&#160;</td><td class="fielddoc"><p>Sampling Ambisonic Decoder (SAD): transpose of the loudspeaker spherical harmonic matrix, scaled by the number of loudspeakers. </p>
<p>This is the simplest decoding approach, as it simply relies on generating hyper- cardioid beamformers for each loudspeaker direction. </p>
</td></tr>
<tr><td class="fieldname"><a id="a796edc50316c6c13a47e667149148b02ae1f628a0188a79ae586ae270a0a8b508"></a>LOUDSPEAKER_DECODER_MMD&#160;</td><td class="fielddoc"><p>Mode-Matching Decoder (MMD): pseudo-inverse of the loudspeaker spherical harmonic matrix. </p>
<p>Due to the pseudo-inverse, more signal energy is lent to regions on the surface of the sphere that are more sparsely populated with loudspeakers. Therefore, one must also be careful, as some loudspeakers may be given a huge amount of signal energy and wake the dead. </p>
</td></tr>
<tr><td class="fieldname"><a id="a796edc50316c6c13a47e667149148b02aa1e10487b21890502a1c72b34d2b7add"></a>LOUDSPEAKER_DECODER_EPAD&#160;</td><td class="fielddoc"><p>Energy-Preserving Ambisonic Decoder (EPAD) [1]. </p>
</td></tr>
<tr><td class="fieldname"><a id="a796edc50316c6c13a47e667149148b02a30fc2a59a858885b6651fd5a1fd34145"></a>LOUDSPEAKER_DECODER_ALLRAD&#160;</td><td class="fielddoc"><p>All-Round Ambisonic Decoder (AllRAD): SAD decoding to t-design, panned for the target loudspeaker directions using VBAP [2]. </p>
<p>Perhaps the Ambisonic decoder we would most recommend for irregular loudspeaker layouts. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a1cc8fcc9d1b9981fbc9e6097c97495d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cc8fcc9d1b9981fbc9e6097c97495d4">&#9670;&nbsp;</a></span>applyDiffCovMatching()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void applyDiffCovMatching </td>
          <td>(</td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>hrtfs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>hrtf_dirs_deg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_dirs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_bands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>decMtx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Imposes a diffuse-field covariance constraint on a given binaural decoding matrix [1]. </p>
<dl class="section note"><dt>Note</dt><dd>decMtx is altered in-place.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hrtfs</td><td>The HRTFs; FLAT: N_bands x NUM_EARS x N_dirs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hrtf_dirs_deg</td><td>HRTF directions; FLAT: N_dirs x 2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_dirs</td><td>Number of HRTF directions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_bands</td><td>Number of frequency bands/bins </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Decoding order </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weights</td><td>Integration weights (set to NULL if not available); N_dirs x 1 </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">decMtx</td><td>Decoding matrix; FLAT: N_bands x NUM_EARS x (order+1)^2</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>[1] Zaunschirm M, Schörkhuber C, Höldrich R. Binaural rendering of Ambisonic signals by head-related impulse response time alignment and a diffuseness constraint. The Journal of the Acoustical Society of America. 2018 Jun 19;143(6):3616-27 </dd></dl>

</div>
</div>
<a id="aa84a59d7917e33747541580167c02e76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa84a59d7917e33747541580167c02e76">&#9670;&nbsp;</a></span>getBinauralAmbiDecoderFilters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getBinauralAmbiDecoderFilters </td>
          <td>(</td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>hrtfs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>hrtf_dirs_deg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_dirs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fftSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="saf__hoa_8h.html#a35e46e1cae92fe146d3037df17c22e0a">BINAURAL_AMBI_DECODER_METHODS</a>&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>itd_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>enableDiffCM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>enableMaxrE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>decFilters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes ambisonic decoding filters for a given HRTF set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hrtfs</td><td>The HRTFs; FLAT: (fftSize/2+1) x NUM_EARS x N_dirs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hrtf_dirs_deg</td><td>HRTF directions; FLAT: N_dirs x 2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_dirs</td><td>Number of HRTF directions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fftSize</td><td>FFT size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fs</td><td>Sampling rate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">method</td><td>Decoding method (see BINAURAL_AMBI_DECODER_METHODS enum) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Decoding order </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">itd_s</td><td>Only needed for BINAURAL_DECODER_TA decoder (can set to NULL if using different method); N_dirs x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weights</td><td>Integration weights (set to NULL if not available); N_dirs x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enableDiffCM</td><td>Set to '0' to disable diffuse correction, '1' to enable </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enableMaxrE</td><td>Set to '0' to disable maxRE weighting, '1' to enable </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">decFilters</td><td>Decoding filters; FLAT: NUM_EARS x (order+1)^2 x fftSize </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a291c22e193e90d410b9ec3c5f3a01a11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a291c22e193e90d410b9ec3c5f3a01a11">&#9670;&nbsp;</a></span>getBinauralAmbiDecoderMtx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getBinauralAmbiDecoderMtx </td>
          <td>(</td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>hrtfs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>hrtf_dirs_deg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_dirs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_bands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="saf__hoa_8h.html#a35e46e1cae92fe146d3037df17c22e0a">BINAURAL_AMBI_DECODER_METHODS</a>&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>freqVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>itd_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>enableDiffCM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>enableMaxrE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>decMtx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes binaural ambisonic decoding matrices (one per frequency) at a specific order, for a given HRTF set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hrtfs</td><td>The HRTFs; FLAT: N_bands x NUM_EARS x N_dirs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hrtf_dirs_deg</td><td>HRTF directions; FLAT: N_dirs x 2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_dirs</td><td>Number of HRTF directions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_bands</td><td>Number of frequency bands/bins </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">method</td><td>Decoding method (see BINAURAL_AMBI_DECODER_METHODS enum) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Decoding order </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">freqVector</td><td>Only needed for BINAURAL_DECODER_TA or BINAURAL_DECODER_MAGLS decoders (set to NULL if using a different method); N_bands x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">itd_s</td><td>Only needed for BINAURAL_DECODER_TA decoder (set to NULL if using different method); N_dirs x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weights</td><td>Integration weights (set to NULL if not available); N_dirs x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enableDiffCM</td><td>Set to '0' to disable diffuse correction, '1' to enable </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enableMaxrE</td><td>Set to '0' to disable maxRE weighting, '1' to enable </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">decMtx</td><td>Decoding matrices (one per frequency); FLAT: N_bands x NUM_EARS x (order+1)^2 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afdbcb0988d23373cf5062d2fa2a283da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdbcb0988d23373cf5062d2fa2a283da">&#9670;&nbsp;</a></span>getLoudspeakerAmbiDecoderMtx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getLoudspeakerAmbiDecoderMtx </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>ls_dirs_deg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nLS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="saf__hoa_8h.html#aba54133ba006a9eef3d417bb11983fcb">LOUDSPEAKER_AMBI_DECODER_METHODS</a>&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>enableMaxrE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>decMtx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes an ambisonic decoding matrix of a specific order, for a specific loudspeaker layout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ls_dirs_deg</td><td>Loudspeaker directions in DEGREES [azi elev]; FLAT: nLS x 2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nLS</td><td>Number of loudspeakers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">method</td><td>Decoding method (see "LOUDSPEAKER_AMBI_DECODER_METHODS" enum) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Decoding order </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enableMaxrE</td><td>Set to '0' to disable, '1' to enable </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">decMtx</td><td>Decoding matrix; FLAT: nLS x (order+1)^2 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af2dc357da0a7df362e1d53a91936955c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2dc357da0a7df362e1d53a91936955c">&#9670;&nbsp;</a></span>getMaxREweights()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getMaxREweights </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>diagMtxFlag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>a_n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the weights required to manipulate a hyper-cardioid beam-pattern, such that it has maximum energy in the given look-direction. </p>
<p>Traditionally, due to the back lobes of beamformers when panning a source via Ambisonics encoding/decoding, there is unwanted energy given to loudspeakers directly opposite the true source direction. This max_rE weighting [1] essentially spatially "tapers" the spherical harmonic patterns used to generate said beams, reducing the contribution of the higher orders to the beam patterns. This results in worse spatial selectivity, as the width of the beam pattern main lobe is widened, however, the back lobes are also reduced; thus mitigating the aforementioned (bigger) problem.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Order of spherical harmonic expansion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">diagMtxFlag</td><td>Set to '0' if you want the weights to be returned as a vector, or to '1' as a diagonal matrix instead. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">a_n</td><td>The max_rE weights, as a vector/diagonal matrix; (order+1)^2 x 1 OR FLAT: (order+1)^2 x (order+1)^2</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>[1] Zotter F, Frank M. All-round ambisonic panning and decoding. Journal of the audio engineering society. 2012 Nov 26; 60(10):807-20. </dd></dl>

</div>
</div>
<a id="ac2804e1b897727e3ed1cd0d6dc74d179"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2804e1b897727e3ed1cd0d6dc74d179">&#9670;&nbsp;</a></span>getRSH()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getRSH </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>dirs_deg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nDirs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes REAL spherical harmonics [1] for multiple directions on the sphere. </p>
<p>The real spherical harmonics are computed WITHOUT the 1/sqrt(4*pi) term. i.e. max(omni) = 1. Also, compared to 'getRSH_recur', this function uses 'unnorm_legendreP' and double precision, so is more suitable for determining 'Y' in an initialisation stage. This version is indeed slower, but more precise; especially for high orders.</p>
<dl class="section note"><dt>Note</dt><dd>This function is mainly intended for Ambisonics, due to the omission of the 1/sqrt(4*pi) scaling, and the directions are given in [azimuth elevation] (degrees). In Ambisonics literature, the format convention of 'Y' is referred to as ACN/N3D</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Order of spherical harmonic expansion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dirs_deg</td><td>Directions on the sphere [azi, ELEVATION] convention, in DEGREES; FLAT: nDirs x 2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nDirs</td><td>Number of directions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Y</td><td>The SH weights [WITHOUT the 1/sqrt(4*pi)]; FLAT: (order+1)^2 x nDirs</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>[1] Rafaely, B. (2015). Fundamentals of spherical array processing (Vol. 8). Berlin: Springer. </dd></dl>

</div>
</div>
<a id="af095b87aecb2c38ce5014669c70d4f6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af095b87aecb2c38ce5014669c70d4f6f">&#9670;&nbsp;</a></span>getRSH_recur()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getRSH_recur </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>dirs_deg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nDirs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes REAL spherical harmonics [1] for multiple directions on the sphere. </p>
<p>The real spherical harmonics are computed WITHOUT the 1/sqrt(4*pi) term. i.e. max(omni) = 1. Also, Compared to 'getRSH', this function uses 'unnorm_legendreP_recur' and single precision, so is more suitable for determining 'Y' in a real-time loop. It sacrifices some precision, as numerical error propogates through the recursion, but it is faster.</p>
<dl class="section note"><dt>Note</dt><dd>This function is mainly intended for Ambisonics, due to the omission of the 1/sqrt(4*pi) scaling, and the directions are given in [azimuth elevation] (degrees). In Ambisonics literature, the format convention of 'Y' is referred to as ACN/N3D</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Order of spherical harmonic expansion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dirs_deg</td><td>Directions on the sphere [azi, ELEVATION] convention, in DEGREES; FLAT: nDirs x 2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nDirs</td><td>Number of directions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Y</td><td>The SH weights [WITHOUT the 1/sqrt(4*pi)]; FLAT: (order+1)^2 x nDirs</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>[1] Rafaely, B. (2015). Fundamentals of spherical array processing (Vol. 8). Berlin: Springer. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_644e041c3a6521da7b27eba0e4eb2b95.html">framework</a></li><li class="navelem"><a class="el" href="dir_56553b6b74e7f4a7717200a52c59b140.html">modules</a></li><li class="navelem"><a class="el" href="dir_99016b584a5af87cdf49f1484dd80da6.html">saf_hoa</a></li><li class="navelem"><a class="el" href="saf__hoa_8h.html">saf_hoa.h</a></li>
    <li class="footer">Generated on Wed Mar 4 2020 13:32:58 for Spatial_Audio_Framework by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>

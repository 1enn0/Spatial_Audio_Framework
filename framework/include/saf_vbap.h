/*
 Copyright 2017-2018 Leo McCormack
 
 Permission to use, copy, modify, and/or distribute this software for any purpose with or
 without fee is hereby granted, provided that the above copyright notice and this permission
 notice appear in all copies.
 
 THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO
 THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT
 SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR
 ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
 CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
 OR PERFORMANCE OF THIS SOFTWARE.
*/ 
/*
 * Filename:
 *     saf_vbap.h
 * Description:
 *     vbap functions largely derived from the MATLAB library by Archontis Politis,
 *     found here: https://github.com/polarch/Vector-Base-Amplitude-Panning
 * Dependencies:
 *     saf_utilities
 * Author, date created:
 *     Leo McCormack, 02.10.2017
 */

#ifndef __SAF_VBAP_H_INCLUDED__
#define __SAF_VBAP_H_INCLUDED__

#ifdef __cplusplus
extern "C" {
#endif
    
/* Generates a 3-D VBAP gain table based on specified source and loudspeaker directions; Note: gtable is returned as NULL if the triangulation failed
 * The VBAP gains are energy normalised; i.e. sum(gains^2) = 1 */
void generateVBAPgainTable3D_srcs(/* Input arguments */
                                  float* src_dirs_deg,       /* Source directions; FLAT: S x 2 */
                                  int S,                     /* number of Sources */
                                  float* ls_dirs_deg,        /* Loudspeaker directions FLAT: L x 2 */
                                  int L,                     /* number of loudspeakers */
                                  int omitLargeTriangles,    /* 0: normal triangultion, 1: remove large triangles too */
                                  int enableDummies,         /* 0: disabled, 1: enabled. Dummies are placed at +/-90 elevation if required */
                                  float spread,              /* spreading in degrees, 0: VBAP, >0: MDAP */
                                  /* Output arguments */
                                  float** gtable,            /* & The 3D VBAP gain table ENERGY NORMALISED; FLAT: N_gtable x L */
                                  int* N_gtable,             /* & number of points in the gain table */
                                  int* nTriangles);          /* & number of loudspeaker triangles */
    
/* Generates a 3-D VBAP gain table based on specified loudspeaker directions; Note: gtable is returned as NULL if the triangulation failed
 * Note that this function generates the VBAP gains for a grid: -180:az_res_deg:180 azimuths and -90:el_res_deg:90 elevations.
 * Which should be accessed as:
 *      N_azi = (int)(360.0f / aziRes + 0.5f) + 1;
 *      aziIndex = (int)(matlab_fmodf(AZIMUTH + 180.0f, 360.0f) / az_res_deg + 0.5f);
 *      elevIndex = (int)((ELEVATION + 90.0f) / el_res_deg + 0.5f);
 *      idx3d = elevIndex * N_azi + aziIndex;
 *      for (ls = 0; ls < L; ls++){
 *          gains3D[ls] =  gtable[idx3d*L+ls];}
 *
 * gains3D are then the loudspeaker gains to pan the source to [AZIMUTH ELEVATION], using the nearest grid point
 * The VBAP gains are energy normalised; i.e. sum(gains^2) = 1 */
void generateVBAPgainTable3D(/* Input arguments */
                             float* ls_dirs_deg,            /* Loudspeaker directions; FLAT: L x 2 */
                             int L,                         /* number of loudspeakers */
                             int az_res_deg,                /* azimuthal resolution in degrees */
                             int el_res_deg,                /* elevation resolution in degrees */
                             int omitLargeTriangles,        /* 0: normal triangulation, 1: remove large triangles */
                             int enableDummies,             /* 0: disabled, 1: enabled. Dummies are placed at +/-90 elevation if required */
                             float spread,                  /* spreading in degrees, 0: VBAP, >0: MDAP */
                             /* Output arguments */
                             float** gtable,                /* & The 3D VBAP gain table ENERGY NORMALISED; FLAT: N_gtable x L */
                             int* N_gtable,                 /* & number of points in the gain table */
                             int* nTriangles);              /* & number of loudspeaker triangles */
    
/* Compresses a VBAP gain table to use less memory and CPU (essentially removes the elements that are zero). Handy
 * for large grid sizes for interpolation purposes. Therefore, the gains are also re-normalised to have the amplitude-preserving
 * property.
 * If vbap_gtable is generated by generateVBAPgainTable3D, then the compressed tables should be accessed as:
 *      N_azi = (int)(360.0f / aziRes + 0.5f) + 1;
 *      aziIndex = (int)(matlab_fmodf(AZIMUTH + 180.0f, 360.0f) / az_res_deg + 0.5f);
 *      elevIndex = (int)((ELEVATION + 90.0f) / el_res_deg + 0.5f);
 *      idx3d = elevIndex * N_azi + aziIndex;
 *      for (i = 0; i < 3; i++){
 *          gains[i] =  vbap_gtableComp[idx3d*3+i];
 *          idx[i] =  vbap_gtableIdx[idx3d*3+i];
 *      }
 *
 * gains are then the gains for loudspeakers(idx) to pan the source to [AZIMUTH ELEVATION], using the nearest grid point
 * The VBAP gains are amplitude normalised; i.e. sum(gains) = 1 */
void compressVBAPgainTable3D(/* Input arguments */
                             float* vbap_gtable,            /* The 3D VBAP gain table; nTable x nDirs */
                             int nTable,                    /* number of points in the gain table */
                             int nDirs,                     /* number of loudspeakers */
                             /* Output arguments */
                             float** vbap_gtableComp,       /* & The compressed 3D VBAP gain table AMPLITUDE NORMALISED; FLAT: nTable x 3  */
                             int** vbap_gtableIdx);         /* & The indices for the compressed 3D VBAP gain table; FLAT: nTable x 3  */
    
/* Renormalises a vbap gain table in place, so it may be utilised for interpolation of data (e.g. powermaps or HRTFs).
 * The VBAP gains are amplitude normalised; i.e. sum(gains) = 1 */
void VBAPgainTable2InterpTable(float* vbap_gtable,          /* vbap gain table; nTable x nDirs */
                               int nTable,                  /* number of points in the gain table */
                               int nDirs);                  /* number of loudspeakers */
    
/* Generates a 2-D VBAP gain table based on specified source and loudspeaker directions
 * The VBAP gains are energy normalised; i.e. sum(gains^2) = 1 */
void generateVBAPgainTable2D_srcs(/* Input arguments */
                                  float* src_dirs_deg,      /* Source directions FLAT: L x 2 (elev assumed to be 0 for all) */
                                  int S,                    /* number of sources */
                                  float* ls_dirs_deg,       /* Loudspeaker directions FLAT: L x 2 (elev assumed to be 0 for all) */
                                  int L,                    /* number of loudspeakers */
                                  /* Output arguments */
                                  float** gtable,           /* & the 2D VBAP gain table ENERGY NORMALISED; FLAT: S x L */
                                  int* N_gtable,            /* & number of points in the gain table, N_gtable=S */
                                  int* nPairs);             /* & number of loudspeaker pairs */
    
/* Generates a 2-D VBAP gain table based on specified loudspeaker directions
 * Note that this function generates the VBAP gains for a grid: -180:az_res_deg:180 azimuths.
 * Which should be accessed as:
 *      aziIndex = (int)(matlab_fmodf(AZIMUTH + 180.0f, 360.0f) / az_res_deg + 0.5f);
 *      idx2d = aziIndex;
 *      for (ls = 0; ls < L; ls++){
 *          gains2D[ls] =  gtable[idx2d*L+ls];}
 *
 * gains2D are then the loudspeaker gains to pan the source to [AZIMUTH 0], using the nearest grid point
 * The VBAP gains are energy normalised; i.e. sum(gains^2) = 1 */
void generateVBAPgainTable2D(/* Input arguments */
                             float* ls_dirs_deg,            /* Loudspeaker directions FLAT: L x 2 (elev assumed to be 0 for all) */
                             int L,                         /* number of loudspeakers */
                             int az_res_deg,                /* azimuthal resolution in degrees */
                             /* Output arguments */
                             float** gtable,                /* & the 2D VBAP gain table ENERGY NORMALISED; FLAT: N_gtable x L */
                             int* N_gtable,                 /* & number of points in the gain table */
                             int* nPairs);                  /* & number of loudspeaker pairs */
    
/* Calculates the frequency dependent pValues, which can be applied to energy normalised VBAP gains
 * This is performed as:
 * if(pValues[band] != 2.0f){
 *     gains3D_sum_pvf = 0.0f;
 *     for (i = 0; i < nLoudspeakers; i++){
 *          gains3D_sum_pvf += powf(MAX(gains[i], 0.0f), pValues[band]);}
 *     gains3D_sum_pvf = powf(gains3D_sum_pvf, 1.0f/(pValues[band]+2.23e-13f));
 *     for (i = 0; i < nLoudspeakers; i++){
 *         gains_p[i] = gains[i] / (gains3D_sum_pvf+2.23e-13f);}
 * }
 *
 * Where "gains" are the original energy normalised VBAP gains and "gains_p" have amplitude normalisation for the low frequencies, and
 * energy normalisation at the high frequencies.
 * For more information, the reader is directed to:
 * Laitinen, M., Vilkamo, J., Jussila, K., Politis, A., Pulkki, V. (2014). Gain normalisation in amplitude panning as a function of
 * frequency and room reverberance. 55th International Conference of the AES. Helsinki, Finland.
 */
void getPvalues(/* Input arguments */
                float DTT,                                  /* 0..1 0: for normal room, 1: for anechoic room, 0.5: for listening room */
                float* freq,                                /* frequency vector in Hz; nFreq x 1 */
                int nFreq,                                  /* number of frequencies in the frequency vector */
                /* Output arguments */
                float* pValues);                            /* pValues for each frequency; nFreq x 1 */
    
#ifdef __cplusplus
}
#endif

#endif /* __SAF_VBAP_H_INCLUDED__ */




